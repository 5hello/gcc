Bottom: 45dcd80e67e16ed9b39d407a037212a9c5829812
Top:    328aa60e362e607ccf1653397f6b91fa58898607
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2015-11-26 18:57:41 -0200

extend API to support templates

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 7774248..bbd6b8f 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -204,6 +204,190 @@ GCC_METHOD2 (gcc_type, build_pointer_to_member_type,
 	     gcc_type,			   /* Argument CLASS_TYPE.  */
 	     gcc_type) 			   /* Argument MEMBER_TYPE.  */
 
+/* Start a template parameter list, so that subsequent
+   build_template_typename_parm and build_template_value_parm calls
+   create template parameters in the list.  The list is closed by a
+   new_decl call with GCC_CP_SYMBOL_FUNCTION or GCC_CP_SYMBOL_CLASS,
+   that, when the scope is a template parameter list, closes the
+   parameter list and declares a template function or a template class
+   with the parameter list.  */
+
+GCC_METHOD0 (int, start_new_template_decl)
+
+/* Build a typename template-parameter (e.g., the T in template
+   <typename T = X>).  Either PACK_P should be nonzero, to indicate an
+   argument pack (the last argument in a variadic template argument
+   list, as in template <typename... T>), or DEFAULT_TYPE may be
+   non-NULL to set the default type argument (e.g. X) for the template
+   parameter.  FILENAME and LINE_NUMBER may specify the source
+   location in which the template parameter was declared.  */
+
+GCC_METHOD5 (gcc_type, new_template_typename_parm,
+	     const char *,			      /* Argument ID.  */
+	     int /* bool */,			  /* Argument PACK_P.  */
+	     gcc_type,			    /* Argument DEFAULT_TYPE.  */
+	     const char *,			/* Argument FILENAME.  */
+	     unsigned int)		     /* Argument LINE_NUMBER.  */
+
+/* Build a template template-parameter (e.g., the T in template
+   <template <[...]> class T = X>).  DEFAULT_TEMPL may be non-NULL to
+   set the default type-template argument (e.g. X) for the template
+   template parameter.  FILENAME and LINE_NUMBER may specify the
+   source location in which the template parameter was declared.  */
+
+GCC_METHOD5 (gcc_decl, new_template_template_parm,
+	     const char *,			      /* Argument ID.  */
+	     int /* bool */,			  /* Argument PACK_P.  */
+	     gcc_decl,			   /* Argument DEFAULT_TEMPL.  */
+	     const char *,			/* Argument FILENAME.  */
+	     unsigned int)		     /* Argument LINE_NUMBER.  */
+
+/* Build a value template-parameter (e.g., the V in template <typename
+   T, T V> or in template <int V = X>).  DEFAULT_VALUE may be non-NULL
+   to set the default value argument for the template parameter (e.g.,
+   X).  FILENAME and LINE_NUMBER may specify the source location in
+   which the template parameter was declared.  */
+
+GCC_METHOD5 (gcc_decl, new_template_value_parm,
+	     gcc_type,			  	    /* Argument TYPE.  */
+	     const char *,			      /* Argument ID.  */
+	     gcc_expr,			   /* Argument DEFAULT_VALUE.  */
+	     const char *,			/* Argument FILENAME.  */
+	     unsigned int)		     /* Argument LINE_NUMBER.  */
+
+/* Build a template-dependent typename (e.g., typename T::bar or
+   typename T::template bart<X> or T<X>).  ENCLOSING_TYPE should be
+   the nested name specifier (e.g., T), ID should be the name of the
+   member of the ENCLOSING_TYPE (e.g., bar or bart, or NULL), and
+   TARGS should be non-NULL and specify the template arguments
+   (e.g. <X>) iff ID is a template class or ID is NULL and
+   ENCLOSING_TYPE is a class template.  */
+
+GCC_METHOD3 (gcc_type, new_dependent_typename,
+	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+	     const char *,			      /* Argument ID.  */
+	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
+
+/* Build a template-dependent class template (e.g., typename
+   T::template bar).  ENCLOSING_TYPE should be the nested name
+   specifier (e.g., T), ID should be the name of the class template
+   member of the ENCLOSING_TYPE (e.g., bar).  */
+
+GCC_METHOD2 (gcc_decl, new_dependent_class_template,
+	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+	     const char *)			      /* Argument ID.  */
+
+/* Build a template-dependent template type specialization (e.g.,
+   T<A>).  TEMPLATE_DECL should be a template template parameter
+   (e.g., the T in template <template <[...]> class T = X>), and TARGS
+   should specify the template arguments (e.g. <A>).  */
+
+GCC_METHOD2 (gcc_type, new_dependent_typespec,
+	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
+	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
+
+/* Build a template-dependent value expression (e.g., T::val or
+   T::template f<X>).  ENCLOSING_TYPE should be the nested name
+   specifier (e.g., T), ID should be the name of the member of the
+   ENCLOSING_TYPE (e.g., val or f), and TARGS should list template
+   arguments (e.g. <X>) when f is explicitly qualified as a template,
+   or be NULL otherwise.  */
+
+GCC_METHOD3 (gcc_expr, new_dependent_value_expr,
+	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+	     const char *,			      /* Argument ID.  */
+	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
+
+/* Build a gcc_expr for the value VALUE in type TYPE.  */
+
+GCC_METHOD2 (gcc_expr, literal_expr,
+	     gcc_type,		  /* Argument TYPE.  */
+	     unsigned long)	  /* Argument VALUE.  */
+
+/* Build a gcc_expr that denotes DECL, the declaration of a variable
+   or function in namespace scope, or of a static member variable or
+   function.  */
+
+GCC_METHOD1 (gcc_expr, decl_expr,
+	     gcc_decl)		  /* Argument DECL.  */
+
+/* Build a gcc_expr that denotes the unary operation UNARY_OP applied
+   to the gcc_expr OPERAND.  */
+
+GCC_METHOD2 (gcc_expr, unary_value_expr,
+	     const char *,	  /* Argument UNARY_OP.  */
+	     gcc_expr)		  /* Argument OPERAND.  */
+
+/* Build a gcc_expr that denotes the binary operation BINARY_OP
+   applied to gcc_exprs OPERAND1 and OPERAND2.  */
+
+GCC_METHOD3 (gcc_expr, binary_value_expr,
+	     const char *,	  /* Argument BINARY_OP.  */
+	     gcc_expr,		  /* Argument OPERAND1.  */
+	     gcc_expr)		  /* Argument OPERAND2.  */
+
+/* Build a gcc_expr that denotes the ternary operation TERNARY_OP
+   applied to gcc_exprs OPERAND1, OPERAND2 and OPERAND3.  */
+
+GCC_METHOD4 (gcc_expr, ternary_value_expr,
+	     const char *,	  /* Argument TERNARY_OP.  */
+	     gcc_expr,		  /* Argument OPERAND1.  */
+	     gcc_expr,		  /* Argument OPERAND2.  */
+	     gcc_expr)		  /* Argument OPERAND3.  */
+
+/* Build a gcc_expr that denotes the unary operation UNARY_OP applied
+   to the gcc_type OPERAND, e.g., sizeof.  */
+
+GCC_METHOD2 (gcc_expr, unary_type_expr,
+	     const char *,	  /* Argument UNARY_OP.  */
+	     gcc_type)		  /* Argument OPERAND.  */
+
+/* Build a gcc_expr that denotes the binary operation BINARY_OP
+   applied to gcc_type OPERAND1 and gcc_expr OPERAND2.  Use this for
+   all kinds of type casts, and to form a pointer-to-member.  */
+
+GCC_METHOD3 (gcc_expr, type_value_expr,
+	     const char *,	  /* Argument BINARY_OP.  */
+	     gcc_type,		  /* Argument OPERAND1.  */
+	     gcc_expr)		  /* Argument OPERAND2.  */
+
+/* FIXME: function call operations?  ctor/dtor?  new/delete?  */
+
+/* Return the gcc_type of the gcc_expr OPERAND.
+   Use this for decltype.  */
+
+GCC_METHOD1 (gcc_type, expr_type,
+	     gcc_expr)		  /* Argument OPERAND.  */
+
+/* Introduce a specialization of a template function.
+
+   TEMPLATE_DECL is the template function, and TARGS are the arguments
+   for the specialization.  ADDRESS is the address of the
+   specialization.  FILENAME and LINE_NUMBER specify the source
+   location associated with the template function specialization.  */
+
+GCC_METHOD5 (gcc_decl, specialize_function_template,
+	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
+	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
+	     gcc_address,			 /* Argument ADDRESS.  */
+	     const char *,	      /* Argument FILENAME.  */
+	     unsigned int)	      /* Argument LINE_NUMBER.  */
+
+/* Start defining a specialization of a template class, and enter its
+   own binding level.  Initially it has no fields.
+
+   TEMPLATE_DECL is the template class, and TARGS are the arguments
+   for the specialization.  BASE_CLASSES indicate the base classes of
+   class NAME.  FILENAME and LINE_NUMBER specify the source location
+   associated with the template class specialization.  */
+
+GCC_METHOD5 (gcc_type, start_specialize_class_template,
+	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
+	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
+	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
+	     const char *,	      /* Argument FILENAME.  */
+	     unsigned int)	      /* Argument LINE_NUMBER.  */
+
 /* Create a new 'class' (or 'struct') type, record it in the current
    binding level, and enter its own binding level.  Initially it has
    no fields.
@@ -232,14 +416,14 @@ GCC_METHOD3 (gcc_type, start_new_union_type,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
-/* Add a non-static data member to a struct or union type.  FIELD_NAME
-   is the field's name.  FIELD_TYPE is the type of the field.  BITSIZE
-   and BITPOS indicate where in the struct the field occurs.
+/* Add a non-static data member to the most-recently-started
+   unfinished struct or union type.  FIELD_NAME is the field's name.
+   FIELD_TYPE is the type of the field.  BITSIZE and BITPOS indicate
+   where in the struct the field occurs.
 
    FIXME: how about mutable data members?  */
 
-GCC_METHOD5 (int /* bool */, new_field,
-	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
+GCC_METHOD4 (int /* bool */, new_field,
 	     const char *,		   /* Argument FIELD_NAME.  */
 	     gcc_type,			   /* Argument FIELD_TYPE.  */
 	     unsigned long,		   /* Argument BITSIZE.  */
@@ -250,8 +434,7 @@ GCC_METHOD5 (int /* bool */, new_field,
    cleanups in GCC, and pops to the binding level that was in effect
    before the matching build_class_type or build_union_type.  */
 
-GCC_METHOD2 (int /* bool */, finish_record_or_union,
-	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
+GCC_METHOD1 (int /* bool */, finish_record_or_union,
 	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */
 
 /* Create a new 'enum' type, and record it in the current binding
@@ -267,8 +450,8 @@ GCC_METHOD5 (gcc_type, start_new_enum_type,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
-/* Add a new constant to an enum type.  NAME is the constant's
-   name and VALUE is its value.  */
+/* Add a new constant to an enum type.  NAME is the constant's name
+   and VALUE is its value.  */
 
 GCC_METHOD3 (int /* bool */, build_add_enum_constant,
 	     gcc_type,		       /* Argument ENUM_TYPE.  */
@@ -352,6 +535,13 @@ GCC_METHOD2 (gcc_type, build_array_type,
 	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
 	     int)			  /* Argument NUM_ELEMENTS.  */
 
+/* Create a new array type.  NUM_ELEMENTS is a template-dependent
+   expression.  */
+
+GCC_METHOD2 (gcc_type, build_dependent_array_type,
+	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
+	     gcc_expr)			  /* Argument NUM_ELEMENTS.  */
+
 /* Create a new variably-sized array type.  UPPER_BOUND_NAME is the
    name of a local variable that holds the upper bound of the array;
    it is one less than the array size.  */
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 8a4a849..b5d3095 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-4
+  GCC_CP_FE_VERSION_0 = 0xffffffff-5
 };
 
 /* Qualifiers.  */
@@ -79,6 +79,39 @@ struct gcc_vbase_array
   char /* bool */ *virtualp;
 };
 
+/* Opaque typedef for expressions.  They are used for template
+   arguments, default values for non-type template parameters, and
+   default arguments for functions.  */
+
+typedef unsigned long long gcc_expr;
+
+/* FIXME: do we need to support argument packs?  */
+
+typedef enum
+{ GCC_CP_TPARG_VALUE, GCC_CP_TPARG_CLASS, GCC_CP_TPARG_TEMPL }
+gcc_cp_template_arg_kind;
+
+typedef union
+{ gcc_expr value; gcc_type type; gcc_decl templ; }
+gcc_cp_template_arg;
+
+/* An array of template arguments.  */
+
+struct gcc_cp_template_args
+{
+  /* Number of elements.  */
+
+  int n_elements;
+
+  /* kind[i] indicates what kind of template argument type[i] is.  */
+
+  char /* gcc_cp_template_arg_kind */ *kinds;
+
+  /* The template arguments.  */
+
+  gcc_cp_template_arg *elements;
+};
+
 /* This enumerates the kinds of decls that GDB can create.  */
 
 enum gcc_cp_symbol_kind
@@ -99,6 +132,11 @@ enum gcc_cp_symbol_kind
 
   GCC_CP_SYMBOL_LABEL,
 
+  /* A class, or, in a template parameter list scope, a declaration of
+     a template class, closing the parameter list.  */
+
+  GCC_CP_SYMBOL_CLASS,
+
   GCC_CP_SYMBOL_MASK = 15,
   GCC_CP_FLAG_BASE,
 
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index abe42a0..8eea7f6 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -61,6 +61,7 @@
 #include "diagnostic.h"
 #include "langhooks.h"
 #include "langhooks-def.h"
+#include "decl.h"
 
 #include "callbacks.hh"
 #include "connection.hh"
@@ -477,10 +478,14 @@ plugin_new_decl (cc1_plugin::connection *self,
       gcc_assert (!sym_flags);
       return convert_out (error_mark_node);
 
+      /* FIXME: add GCC_CP_SYMBOL_CLASS.  */
+
     default:
       abort ();
     }
 
+  /* FIXME: check for a template parameter list scope.  */
+
   source_location loc = ctx->get_source_location (filename, line_number);
   bool class_member_p = at_class_scope_p ();
   bool ctor = false, dtor = false, assop = false;
@@ -1012,13 +1017,12 @@ plugin_start_new_union_type (cc1_plugin::connection *self,
 
 int
 plugin_new_field (cc1_plugin::connection *,
-		  gcc_type record_or_union_type_in,
 		  const char *field_name,
 		  gcc_type field_type_in,
 		  unsigned long bitsize,
 		  unsigned long bitpos)
 {
-  tree record_or_union_type = convert_in (record_or_union_type_in);
+  tree record_or_union_type = current_class_type;
   tree field_type = convert_in (field_type_in);
 
   gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (record_or_union_type)));
@@ -1058,10 +1062,9 @@ plugin_new_field (cc1_plugin::connection *,
 
 int
 plugin_finish_record_or_union (cc1_plugin::connection *,
-			       gcc_type record_or_union_type_in,
 			       unsigned long size_in_bytes)
 {
-  tree record_or_union_type = convert_in (record_or_union_type_in);
+  tree record_or_union_type = current_class_type;
 
   gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (record_or_union_type)));
 
@@ -1070,6 +1073,9 @@ plugin_finish_record_or_union (cc1_plugin::connection *,
   gcc_assert (compare_tree_int (TYPE_SIZE_UNIT (record_or_union_type),
 				size_in_bytes) == 0);
 
+  // FIXME: end_template_decl if it's a template?  I don't think so,
+  // we're only defining specializations.  -lxo
+
   return 1;
 }
 
@@ -1246,6 +1252,235 @@ plugin_build_pointer_to_member_type (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (memptr_type));
 }
 
+/* Abuse an unused field of the dummy template parms entry to hold the
+   parm list.  */
+#define TP_PARM_LIST TREE_TYPE (current_template_parms)
+
+int
+plugin_start_new_template_decl (cc1_plugin::connection *self ATTRIBUTE_UNUSED)
+{
+  begin_template_parm_list ();
+
+  TP_PARM_LIST = NULL_TREE;
+
+  return 0;
+}
+
+gcc_type
+plugin_new_template_typename_parm (cc1_plugin::connection *self,
+				   const char *id,
+				   int /* bool */ pack_p,
+				   gcc_type default_type,
+				   const char *filename,
+				   unsigned int line_number)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  source_location loc = ctx->get_source_location (filename, line_number);
+
+  tree parm = finish_template_type_parm (class_type_node, get_identifier (id));
+  parm = build_tree_list (convert_in (default_type), parm);
+
+  gcc_assert (!(pack_p && default_type));
+
+  /* Create a type and a decl for the type parm, and add the decl to
+     TP_PARM_LIST.  */
+  TP_PARM_LIST = process_template_parm (TP_PARM_LIST, loc, parm,
+					/* is_non_type = */ false, pack_p);
+
+  /* Return the type of the newly-added parm decl.  */
+  return convert_out (ctx->preserve (TREE_TYPE (tree_last (TP_PARM_LIST))));
+}
+
+gcc_decl
+plugin_new_template_template_parm (cc1_plugin::connection *self,
+				   const char *id,
+				   int /* bool */ pack_p,
+				   gcc_decl default_templ,
+				   const char *filename,
+				   unsigned int line_number)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  source_location loc = ctx->get_source_location (filename, line_number);
+
+  /* Finish the template parm list that started this template parm.  */
+  end_template_parm_list (TP_PARM_LIST);
+
+  tree parm = finish_template_template_parm (class_type_node,
+					     get_identifier (id));
+  parm = build_tree_list (convert_in (default_templ), parm);
+
+  gcc_assert (!(pack_p && default_templ));
+
+  /* Create a type and a decl for the template parm, and add the decl
+     to TP_PARM_LIST.  */
+  TP_PARM_LIST = process_template_parm (TP_PARM_LIST, loc, parm,
+					/* is_non_type = */ false, pack_p);
+
+  /* Return the decl of the newly-added template template parm.  */
+  return convert_out (ctx->preserve (tree_last (TP_PARM_LIST)));
+}
+
+gcc_decl
+plugin_new_template_value_parm (cc1_plugin::connection *self,
+				gcc_type type,
+				const char *id,
+				gcc_expr default_value,
+				const char *filename,
+				unsigned int line_number)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  source_location loc = ctx->get_source_location (filename, line_number);
+
+  cp_declarator declarator;
+  memset (&declarator, 0, sizeof (declarator));
+  // &declarator = make_id_declarator (NULL, get_identifier (id), sfk_none):
+  declarator.kind = cdk_id;
+  declarator.u.id.qualifying_scope = NULL;
+  declarator.u.id.unqualified_name = get_identifier (id);
+  declarator.u.id.sfk = sfk_none;
+
+  cp_decl_specifier_seq declspec;
+  memset (&declspec, 0, sizeof (declspec));
+  // cp_parser_set_decl_spec_type (&declspec, convert_in (type), -token-, false):
+  declspec.any_specifiers_p = declspec.any_type_specifiers_p = true;
+  declspec.type = convert_in (type);
+  declspec.locations[ds_type_spec] = loc;
+
+  tree parm = grokdeclarator (&declarator, &declspec, TPARM, 0, 0);
+  parm = build_tree_list (convert_in (default_value), parm);
+
+  /* Create a type and a decl for the template parm, and add the decl
+     to TP_PARM_LIST.  */
+  TP_PARM_LIST = process_template_parm (TP_PARM_LIST, loc, parm,
+					/* is_non_type = */ true, false);
+
+  /* Return the newly-added parm decl.  */
+  return convert_out (ctx->preserve (tree_last (TP_PARM_LIST)));
+}
+
+gcc_type
+plugin_new_dependent_typename (cc1_plugin::connection *self,
+			       gcc_type enclosing_type,
+			       const char *id,
+			       const gcc_cp_template_args *targs)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree type = convert_in (enclosing_type);
+  
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_new_dependent_class_template (cc1_plugin::connection *self,
+				     gcc_type enclosing_type,
+				     const char *id)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_new_dependent_typespec (cc1_plugin::connection *self,
+			       gcc_decl template_decl,
+			       const gcc_cp_template_args *targs)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_new_dependent_value_expr (cc1_plugin::connection *self,
+				 gcc_type enclosing_type,
+				 const char *id,
+				 const gcc_cp_template_args *targs)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_literal_expr (cc1_plugin::connection *self,
+		     gcc_type type, unsigned long value)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_decl_expr (cc1_plugin::connection *self, gcc_decl decl)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_unary_value_expr (cc1_plugin::connection *self,
+			 const char *unary_op,
+			 gcc_expr operand)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_binary_value_expr (cc1_plugin::connection *self,
+			  const char *binary_op,
+			  gcc_expr operand1,
+			  gcc_expr operand2)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_ternary_value_expr (cc1_plugin::connection *self,
+			   const char *binary_op,
+			   gcc_expr operand1,
+			   gcc_expr operand2,
+			   gcc_expr operand3)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_unary_type_expr (cc1_plugin::connection *self,
+			const char *unary_op,
+			gcc_type operand)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_type_value_expr (cc1_plugin::connection *self,
+			const char *binary_op,
+			gcc_type operand1,
+			gcc_expr operand2)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_expr_type (cc1_plugin::connection *self,
+		  gcc_expr operand)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_decl
+plugin_specialize_function_template (cc1_plugin::connection *self,
+				     gcc_decl template_decl,
+				     const gcc_cp_template_args *targs,
+				     gcc_address address,
+				     const char *filename,
+				     unsigned int line_number)
+{
+  /* FIXME: implement.  See begin|end_specialization.  */
+}
+
+gcc_type
+plugin_start_specialize_class_template (cc1_plugin::connection *self,
+					gcc_decl template_decl,
+					const gcc_cp_template_args *args,
+					const gcc_vbase_array *base_classes,
+					const char *filename,
+					unsigned int line_number)
+{
+  /* FIXME: implement.  See begin|end_specialization.  */
+}
+
 gcc_type
 plugin_int_type (cc1_plugin::connection *self,
 		 int is_unsigned, unsigned long size_in_bytes)
@@ -1310,6 +1545,14 @@ plugin_build_array_type (cc1_plugin::connection *self,
 }
 
 gcc_type
+plugin_build_dependent_array_type (cc1_plugin::connection *self,
+				   gcc_type element_type_in,
+				   gcc_expr num_elements_in)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
 plugin_build_vla_array_type (cc1_plugin::connection *self,
 			     gcc_type element_type_in,
 			     const char *upper_bound_name)
diff --git a/libcc1/marshall-cp.hh b/libcc1/marshall-cp.hh
index 5f6fc65..8ce13ee 100644
--- a/libcc1/marshall-cp.hh
+++ b/libcc1/marshall-cp.hh
@@ -136,6 +136,78 @@ namespace cc1_plugin
     *result = gva;
     return OK;
   }
+
+  // Send a gcc_cp_template_args marker followed by the array.
+  status
+  marshall (connection *conn, const gcc_cp_template_args *a)
+  {
+    size_t len;
+
+    if (a)
+      len = a->n_elements;
+    else
+      len = (size_t)-1;
+
+    if (!marshall_array_start (conn, 't', len))
+      return FAIL;
+
+    if (!a)
+      return OK;
+
+    if (!marshall_array_elmts (conn, len * sizeof (a->kinds[0]),
+			       a->kinds))
+      return FAIL;
+
+    return marshall_array_elmts (conn, len * sizeof (a->elements[0]),
+				 a->elements);
+  }
+
+  // Read a gcc_vbase_array marker, followed by a gcc_vbase_array.  The
+  // resulting array must be freed by the caller, using 'delete[]' on
+  // elements and virtualp, and 'delete' on the array object itself.
+  status
+  unmarshall (connection *conn, struct gcc_cp_template_args **result)
+  {
+    size_t len;
+
+    if (!unmarshall_array_start (conn, 't', &len))
+      return FAIL;
+
+    if (len == (size_t)-1)
+      {
+	*result = NULL;
+	return OK;
+      }
+
+    struct gcc_cp_template_args *gva = new gcc_cp_template_args;
+
+    gva->n_elements = len;
+    gva->kinds = new char[len];
+
+    if (!unmarshall_array_elmts (conn,
+				 len * sizeof (gva->kinds[0]),
+				 gva->kinds))
+      {
+	delete[] gva->kinds;
+	delete gva;
+	return FAIL;
+      }
+
+    gva->elements = new gcc_cp_template_arg[len];
+
+    if (!unmarshall_array_elmts (conn,
+				 len * sizeof (gva->elements[0]),
+				 gva->elements))
+      {
+	delete[] gva->elements;
+	delete[] gva->kinds;
+	delete gva;
+	return FAIL;
+      }
+
+    *result = gva;
+    return OK;
+  }
 }
 
 #endif // CC1_PLUGIN_MARSHALL_CP_HH
diff --git a/libcc1/rpc.hh b/libcc1/rpc.hh
index be81c49..f9efe04 100644
--- a/libcc1/rpc.hh
+++ b/libcc1/rpc.hh
@@ -126,7 +126,7 @@ namespace cc1_plugin
   };
 
 #ifdef GCC_CP_INTERFACE_H
-  // Specialization for gcc_type_array.
+  // Specialization for gcc_vbase_array.
   template<>
   class argument_wrapper<const gcc_vbase_array *>
   {
@@ -162,6 +162,43 @@ namespace cc1_plugin
     argument_wrapper (const argument_wrapper &);
     argument_wrapper &operator= (const argument_wrapper &);
   };
+
+  // Specialization for gcc_cp_template_args.
+  template<>
+  class argument_wrapper<const gcc_cp_template_args *>
+  {
+  public:
+    argument_wrapper () : m_object (NULL) { }
+    ~argument_wrapper ()
+    {
+      // It would be nicer if gcc_type_array could have a destructor.
+      // But, it is in code shared with gdb and cannot.
+      if (m_object != NULL)
+	{
+	  delete[] m_object->elements;
+	  delete[] m_object->kinds;
+	}
+      delete m_object;
+    }
+
+    operator const gcc_cp_template_args * () const
+    {
+      return m_object;
+    }
+
+    status unmarshall (connection *conn)
+    {
+      return ::cc1_plugin::unmarshall (conn, &m_object);
+    }
+
+  private:
+
+    gcc_cp_template_args *m_object;
+
+    // No copying or assignment allowed.
+    argument_wrapper (const argument_wrapper &);
+    argument_wrapper &operator= (const argument_wrapper &);
+  };
 #endif /* GCC_CP_INTERFACE_H */
 
   // There are two kinds of template functions here: "call" and
