Bottom: 3440063a743f26e7d9b536eb809623198d132a30
Top:    8da1ee3208c85966521e6df3ebcf748e4bbc2352
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-04-07 03:02:21 -0300

introduce global friend support in C++

---

diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 428f6a3..ad341aa 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -5956,6 +5956,9 @@ extern int is_friend				(tree, tree);
 extern void make_friend_class			(tree, tree, bool);
 extern void add_friend				(tree, tree, bool);
 extern tree do_friend				(tree, tree, tree, tree, enum overload_flags, bool);
+extern void add_to_global_friend_list		(tree);
+extern void remove_from_global_friend_list	(tree);
+extern bool is_global_friend			(tree);
 
 /* in init.c */
 extern tree expand_member_init			(tree);
diff --git a/gcc/cp/friend.c b/gcc/cp/friend.c
index 36b000f..5dc6529 100644
--- a/gcc/cp/friend.c
+++ b/gcc/cp/friend.c
@@ -24,6 +24,66 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Friend data structures are described in cp-tree.h.  */
 
+
+/* Scopes (functions, classes, or templates) in the TREE_VALUE of
+   GLOBAL_FRIEND_LIST are regarded as friends of every class.  This is
+   mainly used by libcc1, to enable GDB's code snippets to access
+   private members without disabling access control in general, which
+   could cause different template overload resolution results when
+   accessibility matters (e.g. tests for an accessible member).  */
+
+static tree global_friend_list;
+
+/* Add SCOPE to GLOBAL_FRIEND_LIST.  The same scope may be added
+   multiple times, so that matching removals cancel out.  */
+
+void
+add_to_global_friend_list (tree scope)
+{
+  global_friend_list = tree_cons (NULL_TREE, scope, global_friend_list);
+}
+
+/* Search for SCOPE in the global friend list, and return a pointer to
+   the first tree cons that matches.  The pointer can be used to
+   modify the list.
+
+   A match means the TREE_VALUE is SCOPE or, if an EXACT match is not
+   required, a template that has SCOPE as a specialization.  */
+
+static inline tree *
+find_in_global_friend_list (tree scope, bool exact)
+{
+  for (tree *p = &global_friend_list;
+       *p; p = &TREE_CHAIN (*p))
+    if (TREE_VALUE (*p) == scope
+	|| (!exact
+	    && is_specialization_of_friend (TREE_VALUE (*p), scope)))
+      return p;
+
+  return NULL_TREE;
+}
+
+/* Remove one occurrence of SCOPE from the global friend list.
+   There must be at least one such occurrence.  */
+
+void
+remove_from_global_friend_list (tree scope)
+{
+  tree *p = find_in_global_friend_list (scope, true);
+
+  gcc_assert (p);
+
+  *p = TREE_CHAIN (*p);
+}
+
+/* Return TRUE if SCOPE is in the global friend list.  */
+
+bool
+is_global_friend (tree scope)
+{
+  return !!find_in_global_friend_list (scope, false);
+}
+
 /* Returns nonzero if SUPPLICANT is a friend of TYPE.  */
 
 int
@@ -36,6 +96,9 @@ is_friend (tree type, tree supplicant)
   if (supplicant == NULL_TREE || type == NULL_TREE)
     return 0;
 
+  if (is_global_friend (supplicant))
+    return 1;
+
   declp = DECL_P (supplicant);
 
   if (declp)
diff --git a/gcc/cp/search.c b/gcc/cp/search.c
index 7924611..dc5073c0 100644
--- a/gcc/cp/search.c
+++ b/gcc/cp/search.c
@@ -782,6 +782,9 @@ friend_accessible_p (tree scope, tree decl, tree type, tree otype)
   if (!scope)
     return 0;
 
+  if (is_global_friend (scope))
+    return 1;
+
   /* Is SCOPE itself a suitable P?  */
   if (TYPE_P (scope) && protected_accessible_p (decl, scope, type, otype))
     return 1;
