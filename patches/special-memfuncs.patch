Bottom: fe799671cbc4122d5b2083237fef07f04480c9f7
Top:    9013ead83a147f5b0fc1603a6b7771870ad5aa70
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2015-10-27 04:22:39 -0200

Implement special member functions

---

diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 13df82e..59ac42b 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -1475,6 +1475,7 @@ struct GTY(()) language_function {
   (operator_name_info[(int) (CODE)].identifier)
 #define ansi_assopname(CODE) \
   (assignment_operator_name_info[(int) (CODE)].identifier)
+extern tree ansi_litopname(const char *);
 
 /* TRUE if a tree code represents a statement.  */
 extern bool statement_code_p[MAX_TREE_CODES];
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 1148156..314f1dc 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -13235,6 +13235,14 @@ cp_literal_operator_id (const char* name)
   return identifier;
 }
 
+/* Exported wrapper for cp_literal_operator_id.  */
+
+tree
+ansi_litopname (const char *name)
+{
+  return cp_literal_operator_id (name);
+}
+
 /* Parse an operator.
 
    operator:
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 16bc0db..f063c54 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -447,30 +447,32 @@ plugin_new_decl (cc1_plugin::connection *self,
   enum tree_code code;
   tree decl;
   tree sym_type = convert_in (sym_type_in);
-
-  bool virtualp = false;;
+  enum gcc_cp_symbol_kind sym_flags;
+  sym_flags = (enum gcc_cp_symbol_kind) (sym_kind & GCC_CP_FLAG_MASK);
+  sym_kind = (enum gcc_cp_symbol_kind) (sym_kind & GCC_CP_SYMBOL_MASK);
 
   switch (sym_kind)
     {
-    case GCC_CP_SYMBOL_VIRTUAL_FUNCTION:
-      virtualp = true;
-      /* Fallthrough.  */
     case GCC_CP_SYMBOL_FUNCTION:
       code = FUNCTION_DECL;
+      gcc_assert (!(sym_flags & ~GCC_CP_FLAG_MASK_FUNCTION));
       break;
 
     case GCC_CP_SYMBOL_VARIABLE:
       code = VAR_DECL;
+      gcc_assert (!(sym_flags & ~GCC_CP_FLAG_MASK_VARIABLE));
       break;
 
     case GCC_CP_SYMBOL_TYPEDEF:
       code = TYPE_DECL;
+      gcc_assert (!sym_flags);
       break;
 
     case GCC_CP_SYMBOL_LABEL:
       // FIXME: we aren't ready to handle labels yet.
       // It isn't clear how to translate them properly
       // and in any case a "goto" isn't likely to work.
+      gcc_assert (!sym_flags);
       return convert_out (error_mark_node);
 
     default:
@@ -479,35 +481,339 @@ plugin_new_decl (cc1_plugin::connection *self,
 
   source_location loc = ctx->get_source_location (filename, line_number);
   bool class_member_p = at_class_scope_p ();
+  bool ctor = false, dtor = false;
 
   if (code == FUNCTION_DECL)
     {
-      decl = build_lang_decl_loc (loc, code, identifier, sym_type);
+      if (sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION)
+	{
+#define CHARS2(f,s) (((unsigned char)f << CHAR_BIT) | (unsigned char)s)
+	  switch (CHARS2 (name[0], name[1])) {
+	  case CHARS2 ('C', '1'): // in-charge constructor
+	    identifier = complete_ctor_identifier;
+	    ctor = true;
+	    break;
+	  case CHARS2 ('C', '2'): // not-in-charge constructor
+	    identifier = base_ctor_identifier;
+	    ctor = true;
+	    break;
+	  case CHARS2 ('D', '0'): // deleting destructor
+	    identifier = deleting_dtor_identifier;
+	    dtor = true;
+	    break;
+	  case CHARS2 ('D', '1'): // in-charge destructor
+	    identifier = complete_dtor_identifier;
+	    dtor = true;
+	    break;
+	  case CHARS2 ('D', '2'): // not-in-charge destructor
+	    identifier = base_dtor_identifier;
+	    dtor = true;
+	    break;
+	  case CHARS2 ('n', 'w'): // operator new
+	    identifier = ansi_opname (NEW_EXPR);
+	    break;
+	  case CHARS2 ('n', 'a'): // operator new[]
+	    identifier = ansi_opname (VEC_NEW_EXPR);
+	    break;
+	  case CHARS2 ('d', 'l'): // operator delete
+	    identifier = ansi_opname (DELETE_EXPR);
+	    break;
+	  case CHARS2 ('d', 'a'): // operator delete[]
+	    identifier = ansi_opname (VEC_DELETE_EXPR);
+	    break;
+	  case CHARS2 ('p', 's'): // operator + (unary)
+	    identifier = ansi_opname (PLUS_EXPR);
+	    break;
+	  case CHARS2 ('n', 'g'): // operator - (unary)
+	    identifier = ansi_opname (MINUS_EXPR);
+	    break;
+	  case CHARS2 ('a', 'd'): // operator & (unary)
+	    identifier = ansi_opname (BIT_AND_EXPR);
+	    break;
+	  case CHARS2 ('d', 'e'): // operator * (unary)
+	    identifier = ansi_opname (MULT_EXPR);
+	    break;
+	  case CHARS2 ('c', 'o'): // operator ~
+	    identifier = ansi_opname (BIT_NOT_EXPR);
+	    break;
+	  case CHARS2 ('p', 'l'): // operator +
+	    identifier = ansi_opname (PLUS_EXPR);
+	    break;
+	  case CHARS2 ('m', 'i'): // operator -
+	    identifier = ansi_opname (MINUS_EXPR);
+	    break;
+	  case CHARS2 ('m', 'l'): // operator *
+	    identifier = ansi_opname (MULT_EXPR);
+	    break;
+	  case CHARS2 ('d', 'v'): // operator /
+	    identifier = ansi_opname (TRUNC_DIV_EXPR);
+	    break;
+	  case CHARS2 ('r', 'm'): // operator %
+	    identifier = ansi_opname (TRUNC_MOD_EXPR);
+	    break;
+	  case CHARS2 ('a', 'n'): // operator &
+	    identifier = ansi_opname (BIT_AND_EXPR);
+	    break;
+	  case CHARS2 ('o', 'r'): // operator |
+	    identifier = ansi_opname (BIT_IOR_EXPR);
+	    break;
+	  case CHARS2 ('e', 'o'): // operator ^
+	    identifier = ansi_opname (BIT_XOR_EXPR);
+	    break;
+	  case CHARS2 ('a', 'S'): // operator =
+	    identifier = ansi_assopname (NOP_EXPR);
+	    break;
+	  case CHARS2 ('p', 'L'): // operator +=
+	    identifier = ansi_assopname (PLUS_EXPR);
+	    break;
+	  case CHARS2 ('m', 'I'): // operator -=
+	    identifier = ansi_assopname (MINUS_EXPR);
+	    break;
+	  case CHARS2 ('m', 'L'): // operator *=
+	    identifier = ansi_assopname (MULT_EXPR);
+	    break;
+	  case CHARS2 ('d', 'V'): // operator /=
+	    identifier = ansi_assopname (TRUNC_DIV_EXPR);
+	    break;
+	  case CHARS2 ('r', 'M'): // operator %=
+	    identifier = ansi_assopname (TRUNC_MOD_EXPR);
+	    break;
+	  case CHARS2 ('a', 'N'): // operator &=
+	    identifier = ansi_assopname (BIT_AND_EXPR);
+	    break;
+	  case CHARS2 ('o', 'R'): // operator |=
+	    identifier = ansi_assopname (BIT_IOR_EXPR);
+	    break;
+	  case CHARS2 ('e', 'O'): // operator ^=
+	    identifier = ansi_assopname (BIT_XOR_EXPR);
+	    break;
+	  case CHARS2 ('l', 's'): // operator <<
+	    identifier = ansi_opname (LSHIFT_EXPR);
+	    break;
+	  case CHARS2 ('r', 's'): // operator >>
+	    identifier = ansi_opname (RSHIFT_EXPR);
+	    break;
+	  case CHARS2 ('l', 'S'): // operator <<=
+	    identifier = ansi_assopname (LSHIFT_EXPR);
+	    break;
+	  case CHARS2 ('r', 'S'): // operator >>=
+	    identifier = ansi_assopname (RSHIFT_EXPR);
+	    break;
+	  case CHARS2 ('e', 'q'): // operator ==
+	    identifier = ansi_opname (EQ_EXPR);
+	    break;
+	  case CHARS2 ('n', 'e'): // operator !=
+	    identifier = ansi_opname (NE_EXPR);
+	    break;
+	  case CHARS2 ('l', 't'): // operator <
+	    identifier = ansi_opname (LT_EXPR);
+	    break;
+	  case CHARS2 ('g', 't'): // operator >
+	    identifier = ansi_opname (GT_EXPR);
+	    break;
+	  case CHARS2 ('l', 'e'): // operator <=
+	    identifier = ansi_opname (LE_EXPR);
+	    break;
+	  case CHARS2 ('g', 'e'): // operator >=
+	    identifier = ansi_opname (GE_EXPR);
+	    break;
+	  case CHARS2 ('n', 't'): // operator !
+	    identifier = ansi_opname (TRUTH_NOT_EXPR);
+	    break;
+	  case CHARS2 ('a', 'a'): // operator &&
+	    identifier = ansi_opname (TRUTH_ANDIF_EXPR);
+	    break;
+	  case CHARS2 ('o', 'o'): // operator ||
+	    identifier = ansi_opname (TRUTH_ORIF_EXPR);
+	    break;
+	  case CHARS2 ('p', 'p'): // operator ++
+	    identifier = ansi_opname (POSTINCREMENT_EXPR);
+	    break;
+	  case CHARS2 ('m', 'm'): // operator --
+	    identifier = ansi_opname (POSTDECREMENT_EXPR);
+	    break;
+	  case CHARS2 ('c', 'm'): // operator ,
+	    identifier = ansi_opname (COMPOUND_EXPR);
+	    break;
+	  case CHARS2 ('p', 'm'): // operator ->*
+	    identifier = ansi_opname (MEMBER_REF);
+	    break;
+	  case CHARS2 ('p', 't'): // operator ->
+	    identifier = ansi_opname (COMPONENT_REF);
+	    break;
+	  case CHARS2 ('c', 'l'): // operator ()
+	    identifier = ansi_opname (CALL_EXPR);
+	    break;
+	  case CHARS2 ('i', 'x'): // operator []
+	    identifier = ansi_opname (ARRAY_REF);
+	    break;
+	  case CHARS2 ('c', 'v'): // operator <T> (conversion operator)
+	    identifier = mangle_conv_op_name_for_type (TREE_TYPE (sym_type));
+	    break;
+	    // C++11-only:
+	  case CHARS2 ('l', 'i'): // operator "" <id>
+	    {
+	      char *id = (char *)name + 2;
+	      bool freeid = false;
+	      if (*id >= '0' && *id <= '9')
+		{
+		  unsigned len = 0;
+		  do
+		    {
+		      len *= 10;
+		      len += id[0] - '0';
+		      id++;
+		    }
+		  while (*id && *id >= '0' && *id <= '9');
+		  id = xstrndup (id, len);
+		  freeid = true;
+		}
+	      identifier = ansi_litopname (id);
+	      if (freeid)
+		free (id);
+	    }
+	    break;
+	  case CHARS2 ('q', 'u'): // ternary operator, not overloadable.
+	  default:
+	    gcc_unreachable ();
+	  }
+	}
+      decl = build_lang_decl_loc (loc, code,
+				  (ctor || dtor)
+				  ? DECL_NAME (TYPE_NAME (current_class_type))
+				  : identifier, sym_type);
       SET_DECL_LANGUAGE (decl, lang_cplusplus); // FIXME: current_lang_name is lang_name_c while compiling an extern "C" function, and we haven't switched to a global context at this point, and this breaks function overloading.
+      if (TREE_CODE (sym_type) == METHOD_TYPE)
+	DECL_ARGUMENTS (decl) = build_this_parm (current_class_type,
+						 cp_type_quals (sym_type));
+      for (tree arg = TREE_CODE (sym_type) == METHOD_TYPE
+	     ? TREE_CHAIN (TYPE_ARG_TYPES (sym_type))
+	     : TYPE_ARG_TYPES (sym_type);
+	   arg && arg != void_list_node;
+	   arg = TREE_CHAIN (arg))
+	{
+	  tree parm = cp_build_parm_decl (NULL_TREE, TREE_VALUE (arg));
+	  DECL_CHAIN (parm) = DECL_ARGUMENTS (decl);
+	  DECL_ARGUMENTS (decl) = parm;
+	}
+      DECL_ARGUMENTS (decl) = nreverse (DECL_ARGUMENTS (decl));
       if (class_member_p)
 	{
 	  if (TREE_CODE (sym_type) == FUNCTION_TYPE)
 	    DECL_STATIC_FUNCTION_P (decl) = 1;
-	  if (virtualp)
-	    DECL_VIRTUAL_P (decl) = 1;
-	  // FIXME: ctor, dtor, operators
+	  if (sym_flags & GCC_CP_FLAG_VIRTUAL_FUNCTION)
+	    {
+	      DECL_VIRTUAL_P (decl) = 1;
+	      if (sym_flags & GCC_CP_FLAG_PURE_VIRTUAL_FUNCTION)
+		DECL_PURE_VIRTUAL_P (decl) = 1;
+	      if (sym_flags & GCC_CP_FLAG_FINAL_VIRTUAL_FUNCTION)
+		DECL_FINAL_P (decl) = 1;
+	    }
+	}
+      if (sym_flags & GCC_CP_FLAG_EXPLICIT_FUNCTION)
+	DECL_NONCONVERTING_P (decl) = 1;
+      if (sym_flags & GCC_CP_FLAG_DEFAULTED_FUNCTION)
+	{
+	  DECL_INITIAL (decl) = ridpointers[(int)RID_DEFAULT];
+	  DECL_DEFAULTED_FN (decl) = 1;
+	}
+      if (sym_flags & GCC_CP_FLAG_DELETED_FUNCTION)
+	{
+	  // DECL_INITIAL (decl) = ridpointers[(int)RID_DELETE];
+	  DECL_DELETED_FN (decl) = 1;
+	  DECL_DECLARED_INLINE_P (decl) = 1;
+	  DECL_INITIAL (decl) = error_mark_node;
+	}
+      if (ctor || dtor)
+	{
+	  tree fns = NULL_TREE;
+	  if (ctor)
+	    {
+	      DECL_CONSTRUCTOR_P (decl) = 1;
+	      fns = CLASSTYPE_CONSTRUCTORS (current_class_type);
+	    }
+	  if (dtor)
+	    {
+	      DECL_DESTRUCTOR_P (decl) = 1;
+	      fns = CLASSTYPE_DESTRUCTORS (current_class_type);
+	    }
+	  DECL_CONTEXT (decl) = FROB_CONTEXT (current_class_type);
+	  maybe_retrofit_in_chrg (decl);
+	  for (; fns; fns = OVL_NEXT (fns))
+	    {
+	      tree fn = OVL_CURRENT (fns);
+	      if (TREE_TYPE (decl) == TREE_TYPE (fn))
+		{
+		  decl = fn;
+		  break;
+		}
+	    }
+	  if (!fns)
+	    {
+	      finish_member_declaration (decl);
+	      /* ctors and dtors clones are chained after DECL.
+		 However, we create the clones before TYPE_METHODS is
+		 reversed.  We test for cloned methods after reversal,
+		 however, and the test requires the clones to follow
+		 DECL.  So, we reverse the chain of clones now, so
+		 that it will come out in the right order after
+		 reversal.  */
+	      tree save = DECL_CHAIN (decl);
+	      DECL_CHAIN (decl) = NULL_TREE;
+	      clone_function_decl (decl, /*update_method_vec_p=*/1);
+	      gcc_assert (TYPE_METHODS (current_class_type) == decl);
+	      TYPE_METHODS (current_class_type)
+		= nreverse (TYPE_METHODS (current_class_type));
+	      DECL_CHAIN (decl) = save;
+	    }
+	  /* Reverse the method chain temporarily, so that we can find
+	     the clones after DECL.  The clones are supposed to be
+	     introduced one right after the other, so truncating the
+	     list at DECL for the temporary reversal will yield a very
+	     short list.  */
+	  tree save = DECL_CHAIN (decl), abstract_decl = decl;
+	  DECL_CHAIN (decl) = NULL_TREE;
+	  TYPE_METHODS (current_class_type)
+	    = nreverse (TYPE_METHODS (current_class_type));
+	  for (decl = DECL_CHAIN (decl); decl; decl = DECL_CHAIN (decl))
+	    if (DECL_NAME (decl) == identifier)
+	      break;
+	  TYPE_METHODS (current_class_type)
+	    = nreverse (TYPE_METHODS (current_class_type));
+	  DECL_CHAIN (abstract_decl) = save;
 	}
     }
   else if (class_member_p)
     {
       decl = build_lang_decl_loc (loc, code, identifier, sym_type);
-      if (TREE_CODE (decl) == VAR_DECL)
-	{
-	  DECL_THIS_STATIC (decl) = 1;
-	  // The remainder of this block does the same as:
-	  // set_linkage_for_static_data_member (decl);
-	  TREE_PUBLIC (decl) = 1;
-	  TREE_STATIC (decl) = 1;
-	  DECL_INTERFACE_KNOWN (decl) = 1;
-	}
+
+      gcc_assert (TREE_CODE (decl) == VAR_DECL);
+
+      // FIXME: sym_flags & GCC_CP_FLAG_THREAD_LOCAL_VARIABLE
+      gcc_assert (!(sym_flags & GCC_CP_FLAG_THREAD_LOCAL_VARIABLE));
+
+      if (sym_flags & GCC_CP_FLAG_CONSTEXPR_VARIABLE)
+	DECL_DECLARED_CONSTEXPR_P (decl) = true;
+
+      DECL_THIS_STATIC (decl) = 1;
+      // The remainder of this block does the same as:
+      // set_linkage_for_static_data_member (decl);
+      TREE_PUBLIC (decl) = 1;
+      TREE_STATIC (decl) = 1;
+      DECL_INTERFACE_KNOWN (decl) = 1;
     }
   else
-    decl = build_decl (loc, code, identifier, sym_type);
+    {
+      decl = build_decl (loc, code, identifier, sym_type);
+
+      gcc_assert (TREE_CODE (decl) == VAR_DECL);
+
+      // FIXME: sym_flags & GCC_CP_FLAG_THREAD_LOCAL_VARIABLE
+      gcc_assert (!(sym_flags & GCC_CP_FLAG_THREAD_LOCAL_VARIABLE));
+
+      if (sym_flags & GCC_CP_FLAG_CONSTEXPR_VARIABLE)
+	DECL_DECLARED_CONSTEXPR_P (decl) = true;
+    }
   TREE_USED (decl) = 1;
   TREE_ADDRESSABLE (decl) = 1;
 
@@ -547,7 +853,10 @@ plugin_new_decl (cc1_plugin::connection *self,
     }
 
   if (class_member_p)
-    finish_member_declaration (decl);
+    {
+      if (!(ctor || dtor))
+	finish_member_declaration (decl);
+    }
   else
     decl = safe_pushdecl_maybe_friend (decl, false);
