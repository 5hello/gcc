Bottom: 0617e867c0d25ec183f0efb0b88cacffa7b8f191
Top:    6a3908fe42fc5043de6c43e85636b7f43f2737d5
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-06-25 00:03:47 -0300

split class decl from defs, enable reactivation of local decls

---

diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 5365091..4cee1cf 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -9231,7 +9231,8 @@ is_this_parameter (tree t)
 {
   if (!DECL_P (t) || DECL_NAME (t) != this_identifier)
     return false;
-  gcc_assert (TREE_CODE (t) == PARM_DECL || is_capture_proxy (t));
+  gcc_assert (TREE_CODE (t) == PARM_DECL || is_capture_proxy (t)
+	      || (cp_binding_oracle && TREE_CODE (t) == VAR_DECL));
   return true;
 }
 
diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index b4d5a02..9518245 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -34,19 +34,119 @@
 GCC_METHOD1 (int /* bool */, push_namespace,
 	     const char *)	      /* Argument NAME.  */
 
-/* Push FUNCTION_DECL as the current context.  */
+/* Push TYPE as the current binding level, making its members visible
+   for name lookup.  The current scope before the call must be the
+   scope in which the class was declared.  This should be used if the
+   definition of a class is already finished, but one wishes to define
+   a nested class, or to enter the scope of one of its member
+   functions.  */
+
+GCC_METHOD1 (int /* bool */, push_class,
+	     gcc_type)		/* Argument TYPE.  */
+
+/* Push FUNCTION_DECL as the current (empty) binding level (see
+   reactivate_decl).  The current enclosing scope before the call must
+   be the scope in which the function was declared.  */
 
 GCC_METHOD1 (int /* bool */, push_function,
 	     gcc_decl)	     /* Argument FUNCTION_DECL.  */
 
-/* Pop the namespace last entered with push_namespace, or function
-   last entered with push_function, restoring the binding level in
-   effect before the matching push_* call.  */
+/* Make DECL visible (again?) within SCOPE.  When SCOPE is NULL, it
+   means the current scope; if it is not NULL, it must name a function
+   that is currently active, even if not at the top of the binding
+   chain.
+
+   This function can be used to make e.g. a global function or
+   variable visible in a namespace or local scope (overriding another
+   enclosing definition of the same name), but its most common
+   expected use of this primitive, that gives it its name, is to make
+   declarations visible again after reentering a function scope,
+   because when a function is entered with push_function, that does
+   NOT make any of the declarations nested in it visible for name
+   lookup.
+
+   There is a reason/excuse for that: unlike namespaces and classes,
+   G++ doesn't ever have to reenter function scopes, so its name
+   resolution infrastructure is not prepared to do that.  But wait,
+   there is also a good use for this apparent limitation: a function
+   may contain multiple scopes (blocks), and the name may be bound to
+   different symbols in each of these scopes.  With this interface, as
+   we reenter a function scope, we may choose which symbols to make
+   visible for other declarations nested in that function scope (e.g.,
+   for unresolved names in nested template class default arguments, or
+   in nested template function signatures), or while compiling the
+   code snippet (see FIXME: figure out how to get into the right
+   context).
+
+   Here's some more detail on how reactivate_decl works.  Say there's
+   a function foo whose body looks like this:
+
+   {
+     {
+// point 1
+       class c {} o __attribute__ ((__used__)); // c  , o
+     }
+     struct c {
+       void f() {
+// point 2
+       }
+     } o __attribute__ ((__used__));            // c_0, o_0
+     {
+       class c {} p __attribute__ ((__used__)); // c_1, p
+// point 3
+       o.f();
+     }
+   }
+
+   When we are about to define class c at point 1, we enter the
+   function foo scope, and since no symbols are visible at point 1, we
+   proceed to declare class c.  We may then define the class right
+   away, or, if we leave the function scope, and we later wish to
+   define it, or to define object o, we can reenter the scope and just
+   use the previously-obtained gcc_decl to define the class, without
+   having to reactivate the declaration.
+
+   Now, if we are to set up the binding context for point 2, we have
+   to define c_0::f, and in order to do so, we have to declare and
+   define c_0.  Before we can declare c_0, we MUST at least declare c.
+
+     As a general rule, before we can declare or define any local name
+     with a discriminator, we have to at least declare any other
+     occurrences of the same name in the same enclosing entity with
+     lower or absent discriminator.
+
+   So, we declare c, then we leave the function scope and reenter it
+   so as to declare c_0 (also with name "c", which is why we have to
+   leave and reenter the function scope, otherwise we would get an
+   error becaus eof the duplicate definition; g++ will assign a
+   discriminator because it still remembers there was an earlier
+   declaration of c_0 within the function, it's just no longer in
+   scope), then we can define c_0, including its member function f.
+
+   Likewise, if we wish to define o_0, we have to define o first.  If
+   we wish to declare (and maybe then define) c_1, we have to at least
+   declare (c and) c_0 first.
+
+   Then, as we set up the binding context to compile a code snippet at
+   point 3, we have to activate c_1, o_0 and p.  If the code snippet
+   is at point 2, we don't need to (re)activate anything: just
+   entering the scope of the class containing member function f
+   reactivates the names of its members, including the class name
+   itself.  */
+
+GCC_METHOD2 (int /* bool */, reactivate_decl,
+	     gcc_decl,		/* Argument DECL.  */
+	     gcc_decl)		/* Argument SCOPE.  */
+
+/* Pop the namespace last entered with push_namespace, or class last
+   entered with push_class, or function last entered with
+   push_function, restoring the binding level in effect before the
+   matching push_* call.  */
 
 GCC_METHOD0 (int /* bool */, pop_namespace)
 
 /* Return the NAMESPACE_DECL, TYPE_DECL or FUNCTION_DECL of the
-   current binding level.  */
+   binding level that would be popped by pop_namespace.  */
 
 GCC_METHOD0 (gcc_decl, get_current_binding_level)
 
@@ -270,10 +370,7 @@ GCC_METHOD3 (gcc_decl, define_cdtor_clone,
 GCC_METHOD1 (gcc_type, decl_type,
 	     gcc_decl)            /* Argument DECL.  */
 
-/* Return the declaration for a type.  This is most useful to be able
-   to pass a class to new_friend, since it expects a gcc_decl, but
-   start_new_class_type and start_specialize_class_template return a
-   gcc_type.  */
+/* Return the declaration for a type.  */
 
 GCC_METHOD1 (gcc_decl, type_decl,
 	     gcc_type)            /* Argument TYPE.  */
@@ -610,52 +707,41 @@ GCC_METHOD5 (gcc_decl, specialize_function_template,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
-/* Start defining a specialization of a template class, and enter its
-   own binding level.  Initially it has no fields.
+/* Specialize a template class as an incomplete type.  A definition
+   can be supplied later, with start_class_definition.
 
    TEMPLATE_DECL is the template class, and TARGS are the arguments
-   for the specialization.  BASE_CLASSES indicate the base classes of
-   class NAME.  FILENAME and LINE_NUMBER specify the source location
-   associated with the template class specialization.  */
+   for the specialization.  FILENAME and LINE_NUMBER specify the
+   source location associated with the template class
+   specialization.  */
 
-GCC_METHOD5 (gcc_type, start_specialize_class_template,
+GCC_METHOD4 (gcc_decl, specialize_class_template,
 	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
-	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
-/* Create a new 'class' (or 'struct') type, record it in the current
-   binding level, and enter its own binding level.  Initially it has
-   no fields.
+/* Start defining a 'class', 'struct' or 'union' type, entering its
+   own binding level.  Initially it has no fields.
 
-   NAME is the class name.  BASE_CLASSES indicate the base classes of
-   class NAME.  FILENAME and LINE_NUMBER specify the source location
-   associated with the class.  */
+   TYPEDECL is the forward-declaration of the type, returned by
+   new_decl.  BASE_CLASSES indicate the base classes of class NAME.
+   FILENAME and LINE_NUMBER specify the source location associated
+   with the class definition, should they be different from those of
+   the forward declaration.  */
 
-GCC_METHOD5 (gcc_type, start_new_class_type,
-	     const char *,	      /* Argument NAME.  */
-	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
+GCC_METHOD4 (gcc_type, start_class_definition,
+	     gcc_decl,		      /* Argument TYPEDECL.  */
 	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
-/* Create a new 'union' type, record it in the current binding level,
-   and enter its own binding level.  Initially it has no fields.
-
-   NAME is the union name.  FILENAME and LINE_NUMBER specify its
-   source location.  */
-
-GCC_METHOD4 (gcc_type, start_new_union_type,
-	     const char *,	      /* Argument NAME.  */
-	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
-	     const char *,	      /* Argument FILENAME.  */
-	     unsigned int)	      /* Argument LINE_NUMBER.  */
-
 /* Create a new closure class type, record it as the
    DISCRIMINATOR-numbered closure type in the current scope (or
    associated with EXTRA_SCOPE, if non-NULL), and enter the closure
-   type's own binding level.  Initially it has no fields.
+   type's own binding level.  This primitive would sort of combine
+   new_decl and start_class_definition, if they could be used to
+   introduce a closure type.  Initially it has no fields.
 
    NAME is the class name.  FILENAME and LINE_NUMBER specify the
    source location associated with the class.  EXTRA_SCOPE, if
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 0ebbfe7..9190c10 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-15
+  GCC_CP_FE_VERSION_0 = 0xffffffff-16
 };
 
 /* Qualifiers.  */
@@ -134,13 +134,15 @@ enum gcc_cp_symbol_kind
 
   GCC_CP_SYMBOL_LABEL,
 
-  /* A class (forward declared in new_decl, or introduced in
-     start_new_class_type), or, in a template parameter list scope, a
-     declaration of a template class, closing the parameter list.  */
+  /* A class, forward declared in new_decl (to be later defined in
+     start_class_definition), or, in a template parameter list scope,
+     a declaration of a template class, closing the parameter
+     list.  */
 
   GCC_CP_SYMBOL_CLASS,
 
-  /* A union being introduced with start_new_union_type.  */
+  /* A union, forward declared in new_decl (to be later defined in
+     start_class_definition).  */
 
   GCC_CP_SYMBOL_UNION,
 
@@ -396,6 +398,13 @@ typedef gcc_address gcc_cp_symbol_address_function (void *datum,
 						    struct gcc_cp_context *ctxt,
 						    const char *identifier);
 
+/* The type of the function called by GCC to ask GDB to enter or leave
+   the user expression scope.  */
+
+typedef void gcc_cp_enter_leave_user_expr_scope_function (void *datum,
+							  struct gcc_cp_context
+							  *context);
+
 /* The vtable used by the C front end.  */
 
 struct gcc_cp_fe_vtable
@@ -428,6 +437,8 @@ struct gcc_cp_fe_vtable
   void (*set_callbacks) (struct gcc_cp_context *self,
 			 gcc_cp_oracle_function *binding_oracle,
 			 gcc_cp_symbol_address_function *address_oracle,
+			 gcc_cp_enter_leave_user_expr_scope_function *enter_scope,
+			 gcc_cp_enter_leave_user_expr_scope_function *leave_scope,
 			 void *datum);
 
 #define GCC_METHOD0(R, N) \
diff --git a/libcc1/libcp1.cc b/libcc1/libcp1.cc
index 3827be3..52285b4 100644
--- a/libcc1/libcp1.cc
+++ b/libcc1/libcp1.cc
@@ -59,6 +59,8 @@ struct libcp1 : public gcc_cp_context
 
   gcc_cp_oracle_function *binding_oracle;
   gcc_cp_symbol_address_function *address_oracle;
+  gcc_cp_enter_leave_user_expr_scope_function *enter_scope;
+  gcc_cp_enter_leave_user_expr_scope_function *leave_scope;
   void *oracle_datum;
 
   void (*print_function) (void *datum, const char *message);
@@ -138,6 +140,24 @@ namespace {
 
     return self->address_oracle (self->oracle_datum, self, identifier);
   }
+
+  int
+  cp_call_enter_scope (cc1_plugin::connection *conn)
+  {
+    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;
+
+    self->enter_scope (self->oracle_datum, self);
+    return 1;
+  }
+
+  int
+  cp_call_leave_scope (cc1_plugin::connection *conn)
+  {
+    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;
+
+    self->leave_scope (self->oracle_datum, self);
+    return 1;
+  }
 } /* anonymous namespace */
 
 
@@ -146,12 +166,16 @@ static void
 set_callbacks (struct gcc_cp_context *s,
 	       gcc_cp_oracle_function *binding_oracle,
 	       gcc_cp_symbol_address_function *address_oracle,
+	       gcc_cp_enter_leave_user_expr_scope_function *enter_scope,
+	       gcc_cp_enter_leave_user_expr_scope_function *leave_scope,
 	       void *datum)
 {
   libcp1 *self = (libcp1 *) s;
 
   self->binding_oracle = binding_oracle;
   self->address_oracle = address_oracle;
+  self->enter_scope = enter_scope;
+  self->leave_scope = leave_scope;
   self->oracle_datum = datum;
 }
 
@@ -488,6 +512,14 @@ libcp1_compile (struct gcc_base_context *s,
 			     cp_call_symbol_address>;
   self->connection->add_callback ("address_oracle", fun);
 
+  fun = cc1_plugin::callback<int,
+			     cp_call_enter_scope>;
+  self->connection->add_callback ("enter_scope", fun);
+
+  fun = cc1_plugin::callback<int,
+			     cp_call_leave_scope>;
+  self->connection->add_callback ("leave_scope", fun);
+
   char **argv = new (std::nothrow) char *[self->args.size () + 1];
   if (argv == NULL)
     return 0;
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index d5b6913..f0e88c2 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -62,6 +62,8 @@
 #include "langhooks.h"
 #include "langhooks-def.h"
 #include "decl.h"
+#include "function.h"
+#undef cfun // we want to assign to it, and function.h won't let us
 
 #include "callbacks.hh"
 #include "connection.hh"
@@ -261,21 +263,461 @@ plugin_binding_oracle (enum cp_oracle_request kind, tree identifier)
 		    request, IDENTIFIER_POINTER (identifier));
 }
 
+static int push_count;
+
+/* at_function_scope_p () tests cfun, indicating we're actually
+   compiling the function, but we don't even set it when pretending to
+   enter a function scope.  We use this distinction to tell these two
+   cases apart: we don't want to define e.g. class names in the user
+   expression function's scope, when they're local to the original
+   function, because they'd get the wrong linkage name.  */
+
+static bool
+at_fake_function_scope_p ()
+{
+  return (!cfun || cfun->decl != current_function_decl)
+    && current_scope () == current_function_decl;
+}
+
+static void
+push_fake_function (tree fndecl, scope_kind kind = sk_function_parms)
+{
+  current_function_decl = fndecl;
+  begin_scope (kind, fndecl);
+  ++function_depth;
+  begin_scope (sk_block, NULL);
+}
+
 static void
-plugin_pragma_user_expression (cpp_reader *)
+pop_scope ()
 {
+  if (toplevel_bindings_p () && current_namespace == global_namespace)
+    pop_from_top_level ();
+  else if (at_namespace_scope_p ())
+    pop_namespace ();
+  else if (at_class_scope_p ())
+    popclass ();
+  else
+    {
+      gcc_assert (at_fake_function_scope_p ());
+      gcc_assert (!at_function_scope_p ());
+      gcc_assert (current_binding_level->kind == sk_block
+		  && current_binding_level->this_entity == NULL);
+      leave_scope ();
+      --function_depth;
+      gcc_assert (current_binding_level->this_entity
+		  == current_function_decl);
+      leave_scope ();
+      current_function_decl = NULL;
+      for (cp_binding_level *scope = current_binding_level;
+	   scope; scope = scope->level_chain)
+	if (scope->kind == sk_function_parms)
+	  {
+	    current_function_decl = scope->this_entity;
+	    break;
+	  }
+    }
+}
+
+static void
+supplement_binding (cxx_binding *binding, tree decl)
+{
+  /* FIXME: this is pretty much a copy of supplement_binding_1 in
+     ../gcc/cp/name-lookup.c; the few replaced/removed bits are marked
+     with "// _1:".  */
+  tree bval = binding->value;
+  bool ok = true;
+  tree target_bval = strip_using_decl (bval);
+  tree target_decl = strip_using_decl (decl);
+
+  if (TREE_CODE (target_decl) == TYPE_DECL && DECL_ARTIFICIAL (target_decl)
+      && target_decl != target_bval
+      && (TREE_CODE (target_bval) != TYPE_DECL
+	  /* We allow pushing an enum multiple times in a class
+	     template in order to handle late matching of underlying
+	     type on an opaque-enum-declaration followed by an
+	     enum-specifier.  */
+	  || (processing_template_decl
+	      && TREE_CODE (TREE_TYPE (target_decl)) == ENUMERAL_TYPE
+	      && TREE_CODE (TREE_TYPE (target_bval)) == ENUMERAL_TYPE
+	      && (dependent_type_p (ENUM_UNDERLYING_TYPE
+				    (TREE_TYPE (target_decl)))
+		  || dependent_type_p (ENUM_UNDERLYING_TYPE
+				       (TREE_TYPE (target_bval)))))))
+    /* The new name is the type name.  */
+    binding->type = decl;
+  else if (/* TARGET_BVAL is null when push_class_level_binding moves
+	      an inherited type-binding out of the way to make room
+	      for a new value binding.  */
+	   !target_bval
+	   /* TARGET_BVAL is error_mark_node when TARGET_DECL's name
+	      has been used in a non-class scope prior declaration.
+	      In that case, we should have already issued a
+	      diagnostic; for graceful error recovery purpose, pretend
+	      this was the intended declaration for that name.  */
+	   || target_bval == error_mark_node
+	   /* If TARGET_BVAL is anticipated but has not yet been
+	      declared, pretend it is not there at all.  */
+	   || (TREE_CODE (target_bval) == FUNCTION_DECL
+	       && DECL_ANTICIPATED (target_bval)
+	       && !DECL_HIDDEN_FRIEND_P (target_bval)))
+    binding->value = decl;
+  else if (TREE_CODE (target_bval) == TYPE_DECL
+	   && DECL_ARTIFICIAL (target_bval)
+	   && target_decl != target_bval
+	   && (TREE_CODE (target_decl) != TYPE_DECL
+	       || same_type_p (TREE_TYPE (target_decl),
+			       TREE_TYPE (target_bval))))
+    {
+      /* The old binding was a type name.  It was placed in
+	 VALUE field because it was thought, at the point it was
+	 declared, to be the only entity with such a name.  Move the
+	 type name into the type slot; it is now hidden by the new
+	 binding.  */
+      binding->type = bval;
+      binding->value = decl;
+      binding->value_is_inherited = false;
+    }
+  else if (TREE_CODE (target_bval) == TYPE_DECL
+	   && TREE_CODE (target_decl) == TYPE_DECL
+	   && DECL_NAME (target_decl) == DECL_NAME (target_bval)
+	   && binding->scope->kind != sk_class
+	   && (same_type_p (TREE_TYPE (target_decl), TREE_TYPE (target_bval))
+	       /* If either type involves template parameters, we must
+		  wait until instantiation.  */
+	       || uses_template_parms (TREE_TYPE (target_decl))
+	       || uses_template_parms (TREE_TYPE (target_bval))))
+    /* We have two typedef-names, both naming the same type to have
+       the same name.  In general, this is OK because of:
+
+	 [dcl.typedef]
+
+	 In a given scope, a typedef specifier can be used to redefine
+	 the name of any type declared in that scope to refer to the
+	 type to which it already refers.
+
+       However, in class scopes, this rule does not apply due to the
+       stricter language in [class.mem] prohibiting redeclarations of
+       members.  */
+    ok = false;
+  /* There can be two block-scope declarations of the same variable,
+     so long as they are `extern' declarations.  However, there cannot
+     be two declarations of the same static data member:
+
+       [class.mem]
+
+       A member shall not be declared twice in the
+       member-specification.  */
+  else if (VAR_P (target_decl)
+	   && VAR_P (target_bval)
+	   && DECL_EXTERNAL (target_decl) && DECL_EXTERNAL (target_bval)
+	   && !DECL_CLASS_SCOPE_P (target_decl))
+    {
+      duplicate_decls (decl, binding->value, /*newdecl_is_friend=*/false);
+      ok = false;
+    }
+  else if (TREE_CODE (decl) == NAMESPACE_DECL
+	   && TREE_CODE (bval) == NAMESPACE_DECL
+	   && DECL_NAMESPACE_ALIAS (decl)
+	   && DECL_NAMESPACE_ALIAS (bval)
+	   && ORIGINAL_NAMESPACE (bval) == ORIGINAL_NAMESPACE (decl))
+    /* [namespace.alias]
+
+      In a declarative region, a namespace-alias-definition can be
+      used to redefine a namespace-alias declared in that declarative
+      region to refer only to the namespace to which it already
+      refers.  */
+    ok = false;
+  else if (maybe_remove_implicit_alias (bval))
+    {
+      /* There was a mangling compatibility alias using this mangled name,
+	 but now we have a real decl that wants to use it instead.  */
+      binding->value = decl;
+    }
+  else
+    {
+      // _1: diagnose_name_conflict (decl, bval);
+      ok = false;
+    }
+
+  gcc_assert (ok); // _1: return ok;
+}
+
+static void
+reactivate_decl (tree decl, cp_binding_level *b)
+{
+  bool in_function_p = TREE_CODE (b->this_entity) == FUNCTION_DECL;
+  gcc_assert (in_function_p
+	      || (b == current_binding_level
+		  && !at_class_scope_p ()));
+      
+  tree id = DECL_NAME (decl);
+  tree type = NULL_TREE;
+  if (TREE_CODE (decl) == TYPE_DECL)
+    type = TREE_TYPE (decl);
+
+  if (type && TYPE_NAME (type) == decl
+      && (RECORD_OR_UNION_CODE_P (TREE_CODE (type))
+	  || TREE_CODE (type) == ENUMERAL_TYPE))
+    {
+      gcc_assert (in_function_p && DECL_CONTEXT (decl) == b->this_entity);
+      type = TREE_TYPE (decl);
+    }
+  else
+    {
+      gcc_assert (DECL_CONTEXT (decl) == b->this_entity
+		  || DECL_CONTEXT (decl) == global_namespace
+		  || TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL);
+      type = NULL_TREE;
+    }
+
+  /* Adjust IDENTIFIER_BINDING to what it would have been if we were
+     at binding level B.  Save the binding chain up to that point in
+     [binding, *chainp), and take note of the outermost bindings found
+     before B.  */
+  cxx_binding *binding = IDENTIFIER_BINDING (id), **chainp = NULL;
+  tree *shadowing_type_p = NULL;
+  if (binding)
+    {
+      cp_binding_level *bc = current_binding_level;
+      for (cxx_binding *prev_binding = binding;
+	   prev_binding; prev_binding = prev_binding->previous)
+	{
+	  while (bc != b && bc != prev_binding->scope)
+	    bc = bc->level_chain;
+	  if (bc == b)
+	    {
+	      if (!chainp)
+		binding = NULL;
+	      break;
+	    }
+	  chainp = &prev_binding->previous;
+	  if (type)
+	    for (tree tshadow = prev_binding->scope->type_shadowed;
+		 tshadow; tshadow = TREE_CHAIN (tshadow))
+	      if (TREE_PURPOSE (tshadow) == id)
+		{
+		  shadowing_type_p = &TREE_VALUE (tshadow);
+		  break;
+		}
+	}
+    }
+  if (chainp)
+    {
+      IDENTIFIER_BINDING (id) = *chainp;
+      *chainp = NULL;
+    }
+
+  /* Like push_local_binding, supplement or add a binding to the
+     desired level.  */
+  if (IDENTIFIER_BINDING (id) && IDENTIFIER_BINDING (id)->scope == b)
+    supplement_binding (IDENTIFIER_BINDING (id), decl);
+  else
+    push_binding (id, decl, b);
+
+  /* Now restore the binding chain we'd temporarily removed.  */
+  if (chainp)
+    {
+      *chainp = IDENTIFIER_BINDING (id);
+      IDENTIFIER_BINDING (id) = binding;
+
+      if (type)
+	{
+	  /* Insert the new type binding in the shadowing_type_p
+	     TREE_VALUE chain.  */
+	  tree shadowed_type = NULL_TREE;
+	  if (shadowing_type_p)
+	    {
+	      shadowed_type = *shadowing_type_p;
+	      *shadowing_type_p = type;
+	    }
+
+	  b->type_shadowed = tree_cons (id, shadowed_type, b->type_shadowed);
+	  TREE_TYPE (b->type_shadowed) = type;
+	}
+    }
+  else if (type)
+    {
+      /* Our new binding is the active one, so shadow the earlier
+	 binding.  */
+      b->type_shadowed = tree_cons (id, REAL_IDENTIFIER_TYPE_VALUE (id),
+				    b->type_shadowed);
+      TREE_TYPE (b->type_shadowed) = type;
+      SET_IDENTIFIER_TYPE_VALUE (id, type);
+    }
+
+  /* Record that we have a binding for ID, like add_decl_to_level.  */
+  tree node = build_tree_list (NULL_TREE, decl);
+  TREE_CHAIN (node) = b->names;
+  b->names = node;
+}
+
+/* FIXME: this is for testing purposes.  */
+const char *user_expr_scope = "foo::fool::testme";
+
+static void
+plugin_pragma_push_user_expression (cpp_reader *)
+{
+  if (push_count++)
+    return;
+
+  gcc_assert (!current_class_ptr);
+  gcc_assert (!current_class_ref);
+
+  gcc_assert (!cp_binding_oracle);
   cp_binding_oracle = plugin_binding_oracle;
 
   /* Make the function containing the user expression a global
      friend, so as to bypass access controls in it.  */
   if (at_function_scope_p ())
     add_to_global_friend_list (current_function_decl);
+
+  gcc_assert (at_function_scope_p ());
+  function *save_cfun = cfun;
+  cp_binding_level *orig_binding_level = current_binding_level;
+  {
+    if (user_expr_scope)
+      {
+	push_to_top_level ();
+	char scope[strlen (user_expr_scope) + 1];
+	memcpy (scope, user_expr_scope, sizeof (scope));
+	for (char *save, *tok = strtok_r (scope, ":", &save);
+	     tok; tok = strtok_r (NULL, ":", &save))
+	  {
+	    tree decl = lookup_name (get_identifier (tok));
+	    if (!decl || DECL_CONTEXT (decl) != FROB_CONTEXT (current_scope ()))
+	      {
+		fprintf (stderr, "failed: %s\n", scope);
+		gcc_unreachable ();
+	      }
+
+	    extern int plugin_push_namespace (cc1_plugin::connection *, const char *);
+	    extern int plugin_push_class (cc1_plugin::connection *, gcc_type);
+	    extern int plugin_push_function (cc1_plugin::connection *, gcc_decl);
+
+	    if (TREE_CODE (decl) == NAMESPACE_DECL)
+	      plugin_push_namespace (NULL, tok);
+	    else if (TREE_CODE (decl) == TYPE_DECL)
+	      plugin_push_class (NULL, convert_out (TREE_TYPE (decl)));
+	    else if (TREE_CODE (decl) == FUNCTION_DECL)
+	      plugin_push_function (NULL, convert_out (decl));
+	    else
+	      gcc_unreachable ();
+	  }
+      }
+
+    int success;
+    cc1_plugin::call (current_context, "enter_scope", &success);
+  }
+  gcc_assert (at_fake_function_scope_p () || at_function_scope_p ());
+
+  function *unchanged_cfun = cfun;
+  tree changed_func_decl = current_function_decl;
+
+  gcc_assert (TREE_CODE (DECL_CONTEXT (current_function_decl)) == NAMESPACE_DECL
+	      || current_class_type == DECL_CONTEXT (current_function_decl));
+  push_fake_function (save_cfun->decl, sk_block);
+  current_class_type = NULL_TREE;
+  if (unchanged_cfun)
+    {
+      /* If we get here, GDB did NOT change the context.  */
+      gcc_assert (cfun == save_cfun);
+      gcc_assert (orig_binding_level == current_binding_level->level_chain);
+      gcc_assert (at_function_scope_p ());
+    }
+  else
+    {
+      cfun = save_cfun;
+      gcc_assert (at_function_scope_p ());
+
+      cp_binding_level *b = current_binding_level->level_chain;
+      gcc_assert (b->this_entity == cfun->decl);
+
+      /* Reactivate local names from the previous context.  Use
+	 IDENTIFIER_MARKED to avoid reactivating shadowed names.  */
+      for (cp_binding_level *level = orig_binding_level;;)
+	{
+	  for (tree name = level->names;
+	       name; name = TREE_CHAIN (name))
+	    {
+	      tree decl = name;
+	      if (TREE_CODE (decl) == TREE_LIST)
+		decl = TREE_VALUE (decl);
+	      if (IDENTIFIER_MARKED (DECL_NAME (decl)))
+		continue;
+	      IDENTIFIER_MARKED (DECL_NAME (decl)) = 1;
+	      reactivate_decl (decl, b);
+	    }
+	  if (level->kind == sk_function_parms
+	      && level->this_entity == cfun->decl)
+	    break;
+	  gcc_assert (!level->this_entity);
+	  level = level->level_chain;
+	}
+
+      /* Now, clear the markers.  */
+      for (tree name = b->names; name; name = TREE_CHAIN (name))
+	{
+	  tree decl = name;
+	  if (TREE_CODE (decl) == TREE_LIST)
+	    decl = TREE_VALUE (decl);
+	  gcc_assert (IDENTIFIER_MARKED (DECL_NAME (decl)));
+	  IDENTIFIER_MARKED (DECL_NAME (decl)) = 0;
+	}
+    }
+
+  if (unchanged_cfun || DECL_NONSTATIC_MEMBER_FUNCTION_P (changed_func_decl))
+    {
+      /* Check whether the oracle supplies us with a "this", and if
+	 so, arrange for data members and this itself to be
+	 usable.  */
+      tree this_val = lookup_name (get_identifier ("this"));
+      current_class_ref = !this_val ? NULL_TREE
+	: cp_build_indirect_ref (this_val, RO_NULL, tf_warning_or_error);
+      current_class_ptr = this_val;
+    }
+}
+
+static void
+plugin_pragma_pop_user_expression (cpp_reader *)
+{
+  if (--push_count)
+    return;
+
+  gcc_assert (cp_binding_oracle);
+
+  gcc_assert (at_function_scope_p ());
+  function *save_cfun = cfun;
+  current_class_ptr = NULL_TREE;
+  current_class_ref = NULL_TREE;
+
+  cfun = NULL;
+  pop_scope ();
+  if (TREE_CODE (DECL_CONTEXT (current_function_decl)) != NAMESPACE_DECL)
+    current_class_type = DECL_CONTEXT (current_function_decl);
+  {
+    int success;
+    cc1_plugin::call (current_context, "leave_scope", &success);
+
+    if (user_expr_scope)
+      while (!cfun)
+	pop_scope ();
+    else if (!success)
+      cfun = save_cfun;
+  }
+  gcc_assert (cfun == save_cfun);
+
+  cp_binding_oracle = NULL;
+  gcc_assert (at_function_scope_p ());
 }
 
 static void
 plugin_init_extra_pragmas (void *, void *)
 {
-  c_register_pragma ("GCC", "user_expression", plugin_pragma_user_expression);
+  c_register_pragma ("GCC", "push_user_expression", plugin_pragma_push_user_expression);
+  c_register_pragma ("GCC", "pop_user_expression", plugin_pragma_pop_user_expression);
+  /* FIXME: this one should go once we get GDB to use push and pop.  */
+  c_register_pragma ("GCC", "user_expression", plugin_pragma_push_user_expression);
 }
 
 
@@ -430,59 +872,64 @@ plugin_push_namespace (cc1_plugin::connection *,
 }
 
 int
+plugin_push_class (cc1_plugin::connection *,
+		   gcc_type type_in)
+{
+  tree type = convert_in (type_in);
+  gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (type)));
+  gcc_assert (TYPE_CONTEXT (type) == FROB_CONTEXT (current_scope ()));
+
+  pushclass (type);
+
+  return 1;
+}
+
+int
 plugin_push_function (cc1_plugin::connection *,
 		      gcc_decl function_decl_in)
 {
-  current_function_decl = convert_in (function_decl_in);
-  begin_scope (sk_function_parms, current_function_decl);
-  ++function_depth;
-  begin_scope (sk_block, NULL);
+  tree fndecl = convert_in (function_decl_in);
+  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);
+  gcc_assert (DECL_CONTEXT (fndecl) == FROB_CONTEXT (current_scope ()));
+
+  push_fake_function (fndecl);
 
   return 1;
 }
 
-/* at_function_scope_p () tests cfun, indicating we're actually
-   compiling the function, but we don't even set it when pretending to
-   enter a function scope.  We use this distinction to tell these two
-   cases apart: we don't want to define e.g. class names in the user
-   expression function's scope, when they're local to the original
-   function, because they'd get the wrong linkage name.  */
-
-static bool
-at_fake_function_scope_p ()
+int
+plugin_pop_namespace (cc1_plugin::connection *)
 {
-  return !cfun && current_scope () == current_function_decl;
+  pop_scope ();
+  return 1;
 }
 
 int
-plugin_pop_namespace (cc1_plugin::connection *)
+plugin_reactivate_decl (cc1_plugin::connection *,
+			gcc_decl decl_in,
+			gcc_decl scope_in)
 {
-  if (toplevel_bindings_p () && current_namespace == global_namespace)
-    pop_from_top_level ();
-  else if (at_namespace_scope_p ())
-    pop_namespace ();
+  tree decl = convert_in (decl_in);
+  tree scope = convert_in (scope_in);
+  gcc_assert (TREE_CODE (decl) == VAR_DECL
+	      || TREE_CODE (decl) == FUNCTION_DECL
+	      || TREE_CODE (decl) == TYPE_DECL);
+  cp_binding_level *b;
+  if (scope)
+    {
+      gcc_assert (TREE_CODE (scope) == FUNCTION_DECL);
+      for (b = current_binding_level;
+	   b->this_entity != scope;
+	   b = b->level_chain)
+	gcc_assert (b->this_entity != global_namespace);
+    }
   else
     {
-      gcc_assert (at_fake_function_scope_p ());
-      gcc_assert (!at_function_scope_p ());
-      gcc_assert (current_binding_level->kind == sk_block
-		  && current_binding_level->this_entity == NULL);
-      leave_scope ();
-      --function_depth;
-      gcc_assert (current_binding_level->kind == sk_function_parms
-		  && (current_binding_level->this_entity
-		      == current_function_decl));
-      leave_scope ();
-      current_function_decl = NULL;
-      for (cp_binding_level *scope = current_binding_level;
-	   scope; scope = scope->level_chain)
-	if (scope->kind == sk_function_parms)
-	  {
-	    current_function_decl = scope->this_entity;
-	    break;
-	  }
+      gcc_assert (!at_class_scope_p ());
+      b = current_binding_level;
     }
 
+  reactivate_decl (decl, b);
   return 1;
 }
 
@@ -623,6 +1070,22 @@ plugin_new_using_decl (cc1_plugin::connection *,
   return 1;
 }
 
+static tree
+build_named_class_type (enum tree_code code,
+			tree id,
+			source_location loc)
+{
+  /* See at_fake_function_scope_p.  */
+  gcc_assert (!at_function_scope_p ());
+  tree type = make_class_type (code);
+  tree type_decl = build_decl (loc, TYPE_DECL, id, type);
+  TYPE_NAME (type) = type_decl;
+  TYPE_STUB_DECL (type) = type_decl;
+  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (type);
+
+  return type_decl;
+}
+
 /* Abuse an unused field of the dummy template parms entry to hold the
    parm list.  */
 #define TP_PARM_LIST TREE_TYPE (current_template_parms)
@@ -638,7 +1101,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 		 unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
-  gcc_assert (!strchr (name, ':')); // FIXME: this can go eventually.
+  gcc_assert (!name || !strchr (name, ':')); // FIXME: this can go eventually.
 
   enum tree_code code;
   tree decl;
@@ -679,6 +1142,12 @@ plugin_new_decl (cc1_plugin::connection *self,
       gcc_assert (!sym_type);
       break;
 
+    case GCC_CP_SYMBOL_UNION:
+      code = UNION_TYPE;
+      gcc_assert (!sym_flags);
+      gcc_assert (!sym_type);
+      break;
+
     default:
       gcc_unreachable ();
     }
@@ -707,7 +1176,15 @@ plugin_new_decl (cc1_plugin::connection *self,
   tree identifier;
   if (code != FUNCTION_DECL
       || !(sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION))
-    identifier = get_identifier (name);
+    {
+      if (name)
+	identifier = get_identifier (name);
+      else
+	{
+	  gcc_assert (RECORD_OR_UNION_CODE_P (code));
+	  identifier = make_anon_name ();
+	}
+    }
 
   if (code == FUNCTION_DECL)
     {
@@ -1001,15 +1478,13 @@ plugin_new_decl (cc1_plugin::connection *self,
 	    DECL_ASSIGNMENT_OPERATOR_P (decl) = true;
 	}
     }
-  else if (code == RECORD_TYPE)
+  else if (RECORD_OR_UNION_CODE_P (code))
     {
-      tree type = make_class_type (code);
-      decl = build_decl (loc, TYPE_DECL, identifier, type);
-      TYPE_NAME (type) = decl;
-      TYPE_STUB_DECL (type) = decl;
-      DECL_CONTEXT (decl) = TYPE_CONTEXT (type);
+      decl = build_named_class_type (code, identifier, loc);
+      tree type = TREE_TYPE (decl);
 
-      if (!(sym_flags & GCC_CP_FLAG_CLASS_IS_STRUCT))
+      if (code == RECORD_TYPE
+	  && !(sym_flags & GCC_CP_FLAG_CLASS_IS_STRUCT))
 	CLASSTYPE_DECLARED_CLASS (type) = true;
     }
   else if (class_member_p)
@@ -1057,6 +1532,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 
   if (sym_kind != GCC_CP_SYMBOL_TYPEDEF
       && sym_kind != GCC_CP_SYMBOL_CLASS
+      && sym_kind != GCC_CP_SYMBOL_UNION
       && !template_decl_p && !ctor && !dtor)
     {
       decl_addr_value value;
@@ -1100,7 +1576,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 	 specializations.  */
       gcc_assert (!template_parm_scope_p ());
     }
-  else if (code == RECORD_TYPE)
+  else if (RECORD_OR_UNION_CODE_P (code))
     safe_pushtag (identifier, TREE_TYPE (decl), ts_current);
   else if (class_member_p)
     finish_member_declaration (decl);
@@ -1303,51 +1779,26 @@ start_class_def (tree type,
   return type;
 }
 
-static tree
-build_named_class_type (enum tree_code code,
-			const char *name,
-			const gcc_vbase_array *base_classes,
-			source_location loc)
-{
-  /* See at_fake_function_scope_p.  */
-  gcc_assert (!at_function_scope_p ());
-  tree type = make_class_type (code);
-  tree id = name ? get_identifier (name) : make_anon_name ();
-  tree type_decl = build_decl (loc, TYPE_DECL, id, type);
-  TYPE_NAME (type) = type_decl;
-  TYPE_STUB_DECL (type) = type_decl;
-  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (type);
-  safe_pushtag (id, type, ts_current);
-
-  return start_class_def (type, base_classes);
-}
-
 gcc_type
-plugin_start_new_class_type (cc1_plugin::connection *self,
-			     const char *name,
-			     enum gcc_cp_symbol_kind flags,
-			     const gcc_vbase_array *base_classes,
-			     const char *filename,
-			     unsigned int line_number)
+plugin_start_class_definition (cc1_plugin::connection *self,
+			       gcc_decl typedecl_in,
+			       const gcc_vbase_array *base_classes,
+			       const char *filename,
+			       unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
+  source_location loc = ctx->get_source_location (filename, line_number);
+  tree typedecl = convert_in (typedecl_in);
+  tree type = TREE_TYPE (typedecl);
 
-  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_CLASS);
-  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
-			  | GCC_CP_FLAG_MASK_CLASS))) == 0);
-  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
-
-  tree type = build_named_class_type (RECORD_TYPE, name, base_classes,
-				      ctx->get_source_location (filename,
-								line_number));
-  tree decl = TYPE_NAME (type);
+  gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (type)));
+  gcc_assert (!COMPLETE_TYPE_P (type));
 
-  set_access_flags (decl, flags);
+  DECL_SOURCE_LOCATION (typedecl) = loc;
 
-  if (!(flags & GCC_CP_FLAG_CLASS_IS_STRUCT))
-    CLASSTYPE_DECLARED_CLASS (type) = true;
+  tree result = start_class_def (type, base_classes);
 
-  return convert_out (ctx->preserve (type));
+  return convert_out (ctx->preserve (result));
 }
 
 gcc_type
@@ -1428,29 +1879,6 @@ plugin_get_lambda_expr (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (lambda_object));
 }
 
-gcc_type
-plugin_start_new_union_type (cc1_plugin::connection *self,
-			     const char *name,
-			     enum gcc_cp_symbol_kind flags,
-			     const char *filename,
-			     unsigned int line_number)
-{
-  plugin_context *ctx = static_cast<plugin_context *> (self);
-
-  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_UNION);
-  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK))) == 0);
-  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
-
-  tree type = build_named_class_type (UNION_TYPE, name, NULL,
-				      ctx->get_source_location (filename,
-								line_number));
-  tree decl = TYPE_NAME (type);
-
-  set_access_flags (decl, flags);
-
-  return convert_out (ctx->preserve (type));
-}
-
 gcc_decl
 plugin_new_field (cc1_plugin::connection *,
 		  const char *field_name,
@@ -2990,13 +3418,12 @@ plugin_specialize_function_template (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (decl));
 }
 
-gcc_type
-plugin_start_specialize_class_template (cc1_plugin::connection *self,
-					gcc_decl template_decl,
-					const gcc_cp_template_args *args,
-					const gcc_vbase_array *base_classes,
-					const char *filename,
-					unsigned int line_number)
+gcc_decl
+plugin_specialize_class_template (cc1_plugin::connection *self,
+				  gcc_decl template_decl,
+				  const gcc_cp_template_args *args,
+				  const char *filename,
+				  unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   source_location loc = ctx->get_source_location (filename, line_number);
@@ -3005,9 +3432,7 @@ plugin_start_specialize_class_template (cc1_plugin::connection *self,
   tree tdecl = finish_template_type (name, targlist (args), false);;
   DECL_SOURCE_LOCATION (tdecl) = loc;
 
-  tree type = start_class_def (TREE_TYPE (tdecl), base_classes);
-
-  return convert_out (ctx->preserve (type));
+  return convert_out (ctx->preserve (tdecl));
 }
 
 /* Return a builtin type associated with BUILTIN_NAME.  */
