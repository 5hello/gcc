Bottom: 19f7e5dd8b5faf4e5b13cb0acf98b6ea7a1e0a23
Top:    bc4d56b06105de018160c88a2fbdcf5d0c5629c5
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-04-27 00:47:38 -0300

drop gcc_typedecl in favor of gcc_type all over


---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 437baa6..c520276 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -209,6 +209,26 @@ GCC_METHOD3 (gcc_decl, define_cdtor_clone,
 	     gcc_decl,		      /* Argument CDTOR.  */
 	     gcc_address)	      /* Argument ADDRESS.  */
 
+/* Return the type associated with the given declaration.  This is
+   most useful to obtain the type associated with a forward-declared
+   class, because it is the gcc_type, rather than the gcc_decl, that
+   has to be used to build other types, but new_decl returns a
+   gcc_decl rather than a gcc_type.  This call can in theory be used
+   to obtain the type from any other declaration; it is supposed to
+   return the same type that was supplied when the declaration was
+   created.  */
+
+GCC_METHOD1 (gcc_type, decl_type,
+	     gcc_decl)            /* Argument DECL.  */
+
+/* Return the declaration for a type.  This is most useful to be able
+   to pass a class to new_friend, since it expects a gcc_decl, but
+   start_new_class_type and start_specialize_class_template return a
+   gcc_type.  */
+
+GCC_METHOD1 (gcc_decl, type_decl,
+	     gcc_type)            /* Argument TYPE.  */
+
 /* Declare DECL as a friend of the current class scope, if TYPE is
    NULL, or of TYPE itself otherwise.  DECL may be a function or a
    class, be they template generics, template specializations or not
@@ -288,13 +308,6 @@ GCC_METHOD2 (gcc_type, build_pointer_to_member_type,
 
 GCC_METHOD0 (int /* bool */, start_new_template_decl)
 
-/* Return the declaration associated with the named type.  It is the
-   declaration, rather than the type proper, that has to be passed as
-   a template parameter.  */
-
-GCC_METHOD1 (gcc_typedecl, type_decl,
-	     gcc_type)            /* Argument TYPE.  */
-
 /* Build a typename template-parameter (e.g., the T in template
    <typename T = X>).  Either PACK_P should be nonzero, to indicate an
    argument pack (the last argument in a variadic template argument
@@ -303,10 +316,10 @@ GCC_METHOD1 (gcc_typedecl, type_decl,
    parameter.  FILENAME and LINE_NUMBER may specify the source
    location in which the template parameter was declared.  */
 
-GCC_METHOD5 (gcc_typedecl, new_template_typename_parm,
+GCC_METHOD5 (gcc_type, new_template_typename_parm,
 	     const char *,			      /* Argument ID.  */
 	     int /* bool */,			  /* Argument PACK_P.  */
-	     gcc_typedecl,		    /* Argument DEFAULT_TYPE.  */
+	     gcc_type,			    /* Argument DEFAULT_TYPE.  */
 	     const char *,			/* Argument FILENAME.  */
 	     unsigned int)		     /* Argument LINE_NUMBER.  */
 
@@ -330,7 +343,7 @@ GCC_METHOD5 (gcc_utempl, new_template_template_parm,
    which the template parameter was declared.  */
 
 GCC_METHOD5 (gcc_decl, new_template_value_parm,
-	     gcc_typedecl,		  	    /* Argument TYPE.  */
+	     gcc_type,			  	    /* Argument TYPE.  */
 	     const char *,			      /* Argument ID.  */
 	     gcc_expr,			   /* Argument DEFAULT_VALUE.  */
 	     const char *,			/* Argument FILENAME.  */
@@ -350,8 +363,8 @@ GCC_METHOD5 (gcc_decl, new_template_value_parm,
    member type thereof (returned by new_dependent_typename
    itself).  */
 
-GCC_METHOD3 (gcc_typedecl, new_dependent_typename,
-	     gcc_typedecl,		  /* Argument ENCLOSING_TYPE.  */
+GCC_METHOD3 (gcc_type, new_dependent_typename,
+	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
 	     const char *,			      /* Argument ID.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
@@ -361,7 +374,7 @@ GCC_METHOD3 (gcc_typedecl, new_dependent_typename,
    member of the ENCLOSING_TYPE (e.g., bart).  */
 
 GCC_METHOD2 (gcc_utempl, new_dependent_class_template,
-	     gcc_typedecl,		  /* Argument ENCLOSING_TYPE.  */
+	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
 	     const char *)			      /* Argument ID.  */
 
 /* Build a template-dependent template type specialization (e.g.,
@@ -369,7 +382,7 @@ GCC_METHOD2 (gcc_utempl, new_dependent_class_template,
    (e.g., the T in template <template <[...]> class T = X>), and TARGS
    should specify the template arguments (e.g. <A>).  */
 
-GCC_METHOD2 (gcc_typedecl, new_dependent_typespec,
+GCC_METHOD2 (gcc_type, new_dependent_typespec,
 	     gcc_utempl,		   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
@@ -381,7 +394,7 @@ GCC_METHOD2 (gcc_typedecl, new_dependent_typespec,
    function, or be NULL otherwise.  */
 
 GCC_METHOD3 (gcc_decl, new_dependent_value_expr,
-	     gcc_typedecl,		  /* Argument ENCLOSING_TYPE.  */
+	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
 	     const char *,			      /* Argument ID.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
@@ -441,9 +454,13 @@ GCC_METHOD3 (gcc_expr, type_value_expr,
 /* FIXME: function call operations?  ctor/dtor?  new/delete?  */
 
 /* Return the type of the gcc_expr OPERAND.
-   Use this for decltype.  */
+   Use this for decltype.
+
+   Note: for template-dependent expressions, the result is NULL,
+   because the type is only computed when template argument
+   substitution is performed.  */
 
-GCC_METHOD1 (gcc_typedecl, expr_type,
+GCC_METHOD1 (gcc_type, expr_type,
 	     gcc_expr)		  /* Argument OPERAND.  */
 
 /* Introduce a specialization of a template function.
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 3ae4def..c276d5a 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-9
+  GCC_CP_FE_VERSION_0 = 0xffffffff-10
 };
 
 /* Qualifiers.  */
@@ -61,12 +61,6 @@ enum gcc_cp_ref_qualifiers {
   GCC_CP_REF_QUAL_RVALUE = 2
 };
 
-/* Opaque typedef for type declarations.  They are used for template
-   arguments, defaults for type template parameters, and types used to
-   build type-conversion expressions.  */
-
-typedef unsigned long long gcc_typedecl;
-
 /* Opaque typedef for unbound class templates.  They are used for
    template arguments, and defaults for template template
    parameters.  */
@@ -87,7 +81,7 @@ typedef enum
 gcc_cp_template_arg_kind;
 
 typedef union
-{ gcc_expr value; gcc_typedecl type; gcc_utempl templ; gcc_typedecl pack; }
+{ gcc_expr value; gcc_type type; gcc_utempl templ; gcc_type pack; }
 gcc_cp_template_arg;
 
 /* An array of template arguments.  */
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index e21dfd5..3741dfb 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1541,7 +1541,7 @@ plugin_start_new_template_decl (cc1_plugin::connection *self ATTRIBUTE_UNUSED)
   return 1;
 }
 
-gcc_typedecl
+gcc_decl
 plugin_type_decl (cc1_plugin::connection *,
 		  gcc_type type_in)
 {
@@ -1553,11 +1553,23 @@ plugin_type_decl (cc1_plugin::connection *,
   return convert_out (name);
 }
 
-gcc_typedecl
+gcc_type
+plugin_decl_type (cc1_plugin::connection *,
+		  gcc_decl decl_in)
+{
+  tree decl = convert_in (decl_in);
+
+  tree type = TREE_TYPE (decl);
+  gcc_assert (type);
+
+  return convert_out (type);
+}
+
+gcc_type
 plugin_new_template_typename_parm (cc1_plugin::connection *self,
 				   const char *id,
 				   int /* bool */ pack_p,
-				   gcc_typedecl default_type,
+				   gcc_type default_type,
 				   const char *filename,
 				   unsigned int line_number)
 {
@@ -1681,9 +1693,9 @@ targlist (const gcc_cp_template_args *targs)
   return vec;
 }
 
-gcc_typedecl
+gcc_type
 plugin_new_dependent_typename (cc1_plugin::connection *self,
-			       gcc_typedecl enclosing_type,
+			       gcc_type enclosing_type,
 			       const char *id,
 			       const gcc_cp_template_args *targs)
 {
@@ -1700,7 +1712,7 @@ plugin_new_dependent_typename (cc1_plugin::connection *self,
 
 gcc_utempl
 plugin_new_dependent_class_template (cc1_plugin::connection *self,
-				     gcc_typedecl enclosing_type,
+				     gcc_type enclosing_type,
 				     const char *id)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
@@ -1711,7 +1723,7 @@ plugin_new_dependent_class_template (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (res));
 }
 
-gcc_typedecl
+gcc_type
 plugin_new_dependent_typespec (cc1_plugin::connection *self,
 			       gcc_utempl template_decl,
 			       const gcc_cp_template_args *targs)
@@ -1720,12 +1732,12 @@ plugin_new_dependent_typespec (cc1_plugin::connection *self,
   tree type = convert_in (template_decl);
   tree decl = finish_template_type (type, targlist (targs),
 				    /*entering_scope=*/false);
-  return convert_out (ctx->preserve (decl));
+  return convert_out (ctx->preserve (TREE_TYPE (decl)));
 }
 
 gcc_decl
 plugin_new_dependent_value_expr (cc1_plugin::connection *self,
-				 gcc_typedecl enclosing_type,
+				 gcc_type enclosing_type,
 				 const char *id,
 				 const gcc_cp_template_args *targs)
 {
@@ -1911,7 +1923,7 @@ plugin_ternary_value_expr (cc1_plugin::connection *self,
 gcc_expr
 plugin_unary_type_expr (cc1_plugin::connection *self,
 			const char *unary_op,
-			gcc_typedecl operand)
+			gcc_type operand)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   tree type = convert_in (operand);
@@ -1931,7 +1943,7 @@ plugin_unary_type_expr (cc1_plugin::connection *self,
 gcc_expr
 plugin_type_value_expr (cc1_plugin::connection *self,
 			const char *binary_op,
-			gcc_typedecl /* operand1 */,
+			gcc_type /* operand1 */,
 			gcc_expr /* operand2 */)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
@@ -1952,14 +1964,12 @@ plugin_type_value_expr (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (val));
 }
 
-gcc_typedecl
+gcc_type
 plugin_expr_type (cc1_plugin::connection *,
 		  gcc_expr operand)
 {
   tree op0 = convert_in (operand);
   tree type = TREE_TYPE (op0);
-  if (type)
-    type = TYPE_NAME (type);
   return convert_out (type);
 }
