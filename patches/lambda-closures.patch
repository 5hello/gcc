Bottom: dc7515afd3bafeb8189262f26559c562c443a6ae
Top:    95e679e593393880b8a8a8d8a7c360be2f581067
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-21 04:28:47 -0300

introduce lambda closures support

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index d9e4289..a069e4f 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -204,7 +204,7 @@ GCC_METHOD2 (int /* bool */, new_using_decl,
      cv      operator <T> (conversion operator)
      li<id>  operator "" <id>
 
-   FIXME: How about attributes; static_assert; lambdas?  */
+   FIXME: How about attributes?  */
 
 GCC_METHOD7 (gcc_decl, new_decl,
 	     const char *,	      /* Argument NAME.  */
@@ -604,6 +604,20 @@ GCC_METHOD4 (gcc_type, start_new_union_type,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
+/* Create a new closure class type, record it as the DISCRIMINATORth
+   closure type in associated with EXTRA_SCOPE, and enter the closure
+   type's own binding level.  Initially it has no fields.
+
+   NAME is the class name.  FILENAME and LINE_NUMBER specify the
+   source location associated with the class.  */
+
+GCC_METHOD5 (gcc_type, start_new_closure_type,
+	     int,		      /* Argument DISCRIMINATOR.  */
+	     gcc_decl,		      /* Argument EXTRA_SCOPE.  */
+	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
+	     const char *,	      /* Argument FILENAME.  */
+	     unsigned int)	      /* Argument LINE_NUMBER.  */
+
 /* Add a non-static data member to the most-recently-started
    unfinished struct or union type.  FIELD_NAME is the field's name.
    FIELD_TYPE is the type of the field.  BITSIZE and BITPOS indicate
@@ -670,7 +684,10 @@ GCC_METHOD3 (gcc_type, build_function_type,
    arguments without default values in FUNCTION_TYPE.  Say, if
    FUNCTION_TYPE has an argument list such as (T1, T2, T3, T4 = V0)
    and DEFAULTS has 2 elements (V1, V2), the returned type will have
-   the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0). */
+   the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0).
+
+   Any NULL expressions in DEFAULTS will be marked as deferred, and
+   they should be filled in with set_deferred_function_default_args.  */
 
 GCC_METHOD2 (gcc_type, add_function_default_args,
 	     gcc_type,			     /* Argument FUNCTION_TYPE.  */
@@ -702,6 +719,34 @@ GCC_METHOD4 (gcc_type, build_method_type,
 	     enum gcc_cp_qualifiers,	   /* Argument QUALS.  */
 	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */
 
+/* Fill in the first deferred default args in FUNCTION_DECL with the
+   expressions given in DEFAULTS.  This can be used when the
+   declaration of a parameter is needed to create a default
+   expression, such as taking the size of an earlier parameter, or
+   building a lambda expression in the parameter's context.  */
+
+GCC_METHOD2 (int, set_deferred_function_default_args,
+	     gcc_decl,			     /* Argument FUNCTION_DECL.  */
+	     const struct gcc_cp_function_args *) /* Argument DEFAULTS.  */
+
+/* Return a declaration for the (INDEX - 1)th argument of
+   FUNCTION_DECL, i.e., for the first argument, use zero as the index.
+   If FUNCTION_DECL is a non-static member function, use -1 to get the
+   implicit THIS parameter.  */
+
+GCC_METHOD2 (gcc_decl, get_function_parameter_decl,
+	     gcc_decl,			     /* Argument FUNCTION_DECL.  */
+	     int)				     /* Argument INDEX.  */
+
+/* Return a lambda expr that constructs an instance of CLOSURE_TYPE.
+   Only lambda exprs without any captures can be correctly created
+   through these mechanisms; that's all we need to support lambdas
+   expressions in default parameters, the only kind that may have to
+   be introduced through this interface.  */
+
+GCC_METHOD1 (gcc_expr, get_lambda_expr,
+	     gcc_type)			      /* Argument CLOSURE_TYPE.  */
+
 /* Return an integer type with the given properties.  If BUILTIN_NAME
    is non-NULL, it must name a builtin integral type with the given
    signedness and size, and that is the type that will be returned.  */
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index de467a3..69d3ec9 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-13
+  GCC_CP_FE_VERSION_0 = 0xffffffff-14
 };
 
 /* Qualifiers.  */
@@ -160,6 +160,17 @@ enum gcc_cp_symbol_kind
 
   GCC_CP_SYMBOL_USING,
 
+  /* A (lambda) closure class type.  In many regards this is just like
+     a regular class, but it's not supposed to have base classes, some
+     of the member functions that are usually implicitly-defined are
+     deleted, and it should have an operator() member function that
+     holds the lambda body.  We can't instantiate objects of lambda
+     types from the snippet, but we can interact with them in such
+     ways as passing them to functions that take their types, and
+     calling their body.  */
+
+  GCC_CP_SYMBOL_LAMBDA_CLOSURE,
+
   /* Marker to check that we haven't exceeded GCC_CP_SYMBOL_MASK.  */
   GCC_CP_SYMBOL_END,
 
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 1486948..ec967f0 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1288,6 +1288,72 @@ plugin_start_new_class_type (cc1_plugin::connection *self,
 }
 
 gcc_type
+plugin_start_new_closure_type (cc1_plugin::connection *self,
+			       int discriminator,
+			       gcc_decl extra_scope_in,
+			       enum gcc_cp_symbol_kind flags,
+			       const char *filename,
+			       unsigned int line_number)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree extra_scope = convert_in (extra_scope_in);
+
+  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_LAMBDA_CLOSURE);
+  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK))) == 0);
+
+  bool class_scope_p = at_class_scope_p ();
+  if (extra_scope)
+    switch (TREE_CODE (extra_scope))
+      {
+      case FUNCTION_DECL:
+	break;
+
+      case FIELD_DECL:
+      case VAR_DECL:
+      case PARM_DECL:
+	break;
+
+      default:
+	gcc_unreachable ();
+      }
+
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
+
+  tree lambda_expr = build_lambda_expr ();
+
+  LAMBDA_EXPR_LOCATION (lambda_expr) = ctx->get_source_location (filename,
+								 line_number);
+
+  tree type = begin_lambda_type (lambda_expr);
+
+  /* This replaces record_lambda_scope.  */
+  LAMBDA_EXPR_EXTRA_SCOPE (lambda_expr) = extra_scope;
+  LAMBDA_EXPR_DISCRIMINATOR (lambda_expr) = discriminator;
+
+  tree decl = TYPE_NAME (type);
+  determine_visibility (decl);
+  set_access_flags (decl, flags);
+
+  return convert_out (ctx->preserve (type));
+}
+
+gcc_expr
+plugin_get_lambda_expr (cc1_plugin::connection *self,
+			gcc_type closure_type_in)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree closure_type = convert_in (closure_type_in);
+
+  gcc_assert (LAMBDA_TYPE_P (closure_type));
+
+  tree lambda_expr = CLASSTYPE_LAMBDA_EXPR (closure_type);
+
+  tree lambda_object = build_lambda_object (lambda_expr);
+
+  return convert_out (ctx->preserve (lambda_object));
+}
+
+gcc_type
 plugin_start_new_union_type (cc1_plugin::connection *self,
 			     const char *name,
 			     enum gcc_cp_symbol_kind flags,
@@ -1516,7 +1582,8 @@ plugin_add_function_default_args (cc1_plugin::connection *self,
     {
       gcc_assert (ndargs);
       tree deflt = convert_in (defaults->elements[i]);
-      gcc_assert (deflt);
+      if (!deflt)
+	deflt = error_mark_node;
       TREE_PURPOSE (ndargs) = deflt;
       ndargs = TREE_CHAIN (ndargs);
     }
@@ -1538,6 +1605,62 @@ plugin_add_function_default_args (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (result));
 }
 
+int
+plugin_set_deferred_function_default_args (cc1_plugin::connection *,
+					   gcc_decl function_in,
+					   const struct gcc_cp_function_args
+					   *defaults)
+{
+  tree function = convert_in (function_in);
+
+  gcc_assert (TREE_CODE (function) == FUNCTION_DECL);
+
+  if (!defaults || !defaults->n_elements)
+    return 1;
+
+  tree arg = FUNCTION_FIRST_USER_PARMTYPE (function);
+
+  for (int i = 0; i < defaults->n_elements; i++)
+    {
+      while (arg && TREE_PURPOSE (arg) != error_mark_node)
+	arg = TREE_CHAIN (arg);
+
+      if (!arg)
+	return 0;
+
+      TREE_PURPOSE (arg) = convert_in (defaults->elements[i]);
+      arg = TREE_CHAIN (arg);
+    }
+
+  return 1;
+}
+
+gcc_decl
+plugin_get_function_parameter_decl (cc1_plugin::connection *,
+				    gcc_decl function_in,
+				    int index)
+{
+  tree function = convert_in (function_in);
+
+  gcc_assert (TREE_CODE (function) == FUNCTION_DECL);
+
+  if (index == -1)
+    {
+      gcc_assert (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE);
+
+      return convert_out (DECL_ARGUMENTS (function));
+    }
+
+  gcc_assert (index >= 0);
+
+  tree args = FUNCTION_FIRST_USER_PARM (function);
+
+  for (int i = 0; args && i < index; i++)
+    args = DECL_CHAIN (args);
+
+  return convert_out (args);
+}
+
 gcc_type
 plugin_build_exception_spec_variant (cc1_plugin::connection *self,
 				     gcc_type function_type_in,
