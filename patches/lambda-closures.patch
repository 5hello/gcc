Bottom: 689f19ebf3bf707e7d3f676eb892b3d39aefbdc9
Top:    27f4409d0d6116827a3d1d86269ca4e887d131c7
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-21 04:28:47 -0300

introduce lambda closures support

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index d2f518b..73c7133 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -34,8 +34,14 @@
 GCC_METHOD1 (int /* bool */, push_namespace,
 	     const char *)	      /* Argument NAME.  */
 
-/* Pop the namespace last entered with push_namespace, restoring the
-   binding level in effect before the matching push_namespace.  */
+/* Push FUNCTION_DECL as the current context.  */
+
+GCC_METHOD1 (int /* bool */, push_function,
+	     gcc_decl)	     /* Argument FUNCTION_DECL.  */
+
+/* Pop the namespace last entered with push_namespace, or function
+   last entered with push_function, restoring the binding level in
+   effect before the matching push_* call.  */
 
 GCC_METHOD0 (int /* bool */, pop_namespace)
 
@@ -204,7 +210,7 @@ GCC_METHOD2 (int /* bool */, new_using_decl,
      cv      operator <T> (conversion operator)
      li<id>  operator "" <id>
 
-   FIXME: How about attributes; static_assert; lambdas?  */
+   FIXME: How about attributes?  */
 
 GCC_METHOD7 (gcc_decl, new_decl,
 	     const char *,	      /* Argument NAME.  */
@@ -601,12 +607,29 @@ GCC_METHOD4 (gcc_type, start_new_union_type,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
+/* Create a new closure class type, record it as the
+   DISCRIMINATOR-numbered closure type in the current scope (or
+   associated with EXTRA_SCOPE, if non-NULL), and enter the closure
+   type's own binding level.  Initially it has no fields.
+
+   NAME is the class name.  FILENAME and LINE_NUMBER specify the
+   source location associated with the class.  EXTRA_SCOPE, if
+   non-NULL, must be a PARM_DECL of the current function, but if it is
+   NULL, the current scope needs not be a function.  */
+
+GCC_METHOD5 (gcc_type, start_new_closure_type,
+	     int,		      /* Argument DISCRIMINATOR.  */
+	     gcc_decl,		      /* Argument EXTRA_SCOPE.  */
+	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
+	     const char *,	      /* Argument FILENAME.  */
+	     unsigned int)	      /* Argument LINE_NUMBER.  */
+
 /* Add a non-static data member to the most-recently-started
    unfinished struct or union type.  FIELD_NAME is the field's name.
    FIELD_TYPE is the type of the field.  BITSIZE and BITPOS indicate
    where in the struct the field occurs.  */
 
-GCC_METHOD5 (int /* bool */, new_field,
+GCC_METHOD5 (gcc_decl, new_field,
 	     const char *,		   /* Argument FIELD_NAME.  */
 	     gcc_type,			   /* Argument FIELD_TYPE.  */
 	     enum gcc_cp_symbol_kind,	   /* Argument FIELD_FLAGS.  */
@@ -667,7 +690,10 @@ GCC_METHOD3 (gcc_type, build_function_type,
    arguments without default values in FUNCTION_TYPE.  Say, if
    FUNCTION_TYPE has an argument list such as (T1, T2, T3, T4 = V0)
    and DEFAULTS has 2 elements (V1, V2), the returned type will have
-   the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0). */
+   the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0).
+
+   Any NULL expressions in DEFAULTS will be marked as deferred, and
+   they should be filled in with set_deferred_function_default_args.  */
 
 GCC_METHOD2 (gcc_type, add_function_default_args,
 	     gcc_type,			     /* Argument FUNCTION_TYPE.  */
@@ -699,6 +725,34 @@ GCC_METHOD4 (gcc_type, build_method_type,
 	     enum gcc_cp_qualifiers,	   /* Argument QUALS.  */
 	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */
 
+/* Fill in the first deferred default args in FUNCTION_DECL with the
+   expressions given in DEFAULTS.  This can be used when the
+   declaration of a parameter is needed to create a default
+   expression, such as taking the size of an earlier parameter, or
+   building a lambda expression in the parameter's context.  */
+
+GCC_METHOD2 (int /* bool */, set_deferred_function_default_args,
+	     gcc_decl,			     /* Argument FUNCTION_DECL.  */
+	     const struct gcc_cp_function_args *) /* Argument DEFAULTS.  */
+
+/* Return a declaration for the (INDEX - 1)th argument of
+   FUNCTION_DECL, i.e., for the first argument, use zero as the index.
+   If FUNCTION_DECL is a non-static member function, use -1 to get the
+   implicit THIS parameter.  */
+
+GCC_METHOD2 (gcc_decl, get_function_parameter_decl,
+	     gcc_decl,			     /* Argument FUNCTION_DECL.  */
+	     int)				     /* Argument INDEX.  */
+
+/* Return a lambda expr that constructs an instance of CLOSURE_TYPE.
+   Only lambda exprs without any captures can be correctly created
+   through these mechanisms; that's all we need to support lambdas
+   expressions in default parameters, the only kind that may have to
+   be introduced through this interface.  */
+
+GCC_METHOD1 (gcc_expr, get_lambda_expr,
+	     gcc_type)			      /* Argument CLOSURE_TYPE.  */
+
 /* Return an integer type with the given properties.  If BUILTIN_NAME
    is non-NULL, it must name a builtin integral type with the given
    signedness and size, and that is the type that will be returned.  */
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index de467a3..69d3ec9 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-13
+  GCC_CP_FE_VERSION_0 = 0xffffffff-14
 };
 
 /* Qualifiers.  */
@@ -160,6 +160,17 @@ enum gcc_cp_symbol_kind
 
   GCC_CP_SYMBOL_USING,
 
+  /* A (lambda) closure class type.  In many regards this is just like
+     a regular class, but it's not supposed to have base classes, some
+     of the member functions that are usually implicitly-defined are
+     deleted, and it should have an operator() member function that
+     holds the lambda body.  We can't instantiate objects of lambda
+     types from the snippet, but we can interact with them in such
+     ways as passing them to functions that take their types, and
+     calling their body.  */
+
+  GCC_CP_SYMBOL_LAMBDA_CLOSURE,
+
   /* Marker to check that we haven't exceeded GCC_CP_SYMBOL_MASK.  */
   GCC_CP_SYMBOL_END,
 
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 1118f83..b280af4 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -430,30 +430,84 @@ plugin_push_namespace (cc1_plugin::connection *,
 }
 
 int
+plugin_push_function (cc1_plugin::connection *,
+		      gcc_decl function_decl_in)
+{
+  current_function_decl = convert_in (function_decl_in);
+  begin_scope (sk_function_parms, current_function_decl);
+  ++function_depth;
+  begin_scope (sk_block, NULL);
+
+  return 1;
+}
+
+/* at_function_scope_p () tests cfun, indicating we're actually
+   compiling the function, but we don't even set it when pretending to
+   enter a function scope.  We use this distinction to tell these two
+   cases apart: we don't want to define e.g. class names in the user
+   expression function's scope, when they're local to the original
+   function, because they'd get the wrong linkage name.  */
+
+static bool
+at_fake_function_scope_p ()
+{
+  return !cfun && current_scope () == current_function_decl;
+}
+
+int
 plugin_pop_namespace (cc1_plugin::connection *)
 {
   if (toplevel_bindings_p () && current_namespace == global_namespace)
     pop_from_top_level ();
-  else
+  else if (at_namespace_scope_p ())
     pop_namespace ();
+  else
+    {
+      gcc_assert (at_fake_function_scope_p ());
+      gcc_assert (!at_function_scope_p ());
+      gcc_assert (current_binding_level->kind == sk_block
+		  && current_binding_level->this_entity == NULL);
+      leave_scope ();
+      --function_depth;
+      gcc_assert (current_binding_level->kind == sk_function_parms
+		  && (current_binding_level->this_entity
+		      == current_function_decl));
+      leave_scope ();
+      current_function_decl = NULL;
+      for (cp_binding_level *scope = current_binding_level;
+	   scope; scope = scope->level_chain)
+	if (scope->kind == sk_function_parms)
+	  {
+	    current_function_decl = scope->this_entity;
+	    break;
+	  }
+    }
 
   return 1;
 }
 
-gcc_decl
-plugin_get_current_binding_level (cc1_plugin::connection *)
+static tree
+get_current_scope ()
 {
   tree decl;
 
   if (at_namespace_scope_p ())
     decl = current_namespace;
-  else if (at_function_scope_p ())
-    decl = current_function_decl;
   else if (at_class_scope_p ())
     decl = TYPE_NAME (current_class_type);
+  else if (at_fake_function_scope_p () || at_function_scope_p ())
+    decl = current_function_decl;
   else
     gcc_unreachable ();
 
+  return decl;
+}
+
+gcc_decl
+plugin_get_current_binding_level (cc1_plugin::connection *)
+{
+  tree decl = get_current_scope ();
+
   return convert_out (decl);
 }
 
@@ -1251,6 +1305,8 @@ build_named_class_type (enum tree_code code,
 			const gcc_vbase_array *base_classes,
 			source_location loc)
 {
+  /* See at_fake_function_scope_p.  */
+  gcc_assert (!at_function_scope_p ());
   tree type = make_class_type (code);
   tree id = name ? get_identifier (name) : make_anon_name ();
   tree type_decl = build_decl (loc, TYPE_DECL, id, type);
@@ -1291,6 +1347,81 @@ plugin_start_new_class_type (cc1_plugin::connection *self,
 }
 
 gcc_type
+plugin_start_new_closure_type (cc1_plugin::connection *self,
+			       int discriminator,
+			       gcc_decl extra_scope_in,
+			       enum gcc_cp_symbol_kind flags,
+			       const char *filename,
+			       unsigned int line_number)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree extra_scope = convert_in (extra_scope_in);
+
+  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_LAMBDA_CLOSURE);
+  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK))) == 0);
+
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
+
+  /* See at_fake_function_scope_p.  */
+  gcc_assert (!at_function_scope_p ());
+
+  if (extra_scope)
+    {
+      if (TREE_CODE (extra_scope) == PARM_DECL)
+	{
+	  gcc_assert (at_fake_function_scope_p ());
+	  /* Check that the given extra_scope is one of the parameters of
+	     the current function.  */
+	  for (tree parm = DECL_ARGUMENTS (current_function_decl);
+	       ; parm = DECL_CHAIN (parm))
+	    {
+	      gcc_assert (parm);
+	      if (parm == extra_scope)
+		break;
+	    }
+	}
+      else if (TREE_CODE (extra_scope) == FIELD_DECL)
+	{
+	  gcc_assert (at_class_scope_p ());
+	  gcc_assert (DECL_CONTEXT (extra_scope) == current_class_type);
+	}
+    }
+
+  tree lambda_expr = build_lambda_expr ();
+
+  LAMBDA_EXPR_LOCATION (lambda_expr) = ctx->get_source_location (filename,
+								 line_number);
+
+  tree type = begin_lambda_type (lambda_expr);
+
+  /* Instead of calling record_lambda_scope, do this:  */
+  LAMBDA_EXPR_EXTRA_SCOPE (lambda_expr) = extra_scope;
+  LAMBDA_EXPR_DISCRIMINATOR (lambda_expr) = discriminator;
+
+  tree decl = TYPE_NAME (type);
+  determine_visibility (decl);
+  set_access_flags (decl, flags);
+
+  return convert_out (ctx->preserve (type));
+}
+
+gcc_expr
+plugin_get_lambda_expr (cc1_plugin::connection *self,
+			gcc_type closure_type_in)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree closure_type = convert_in (closure_type_in);
+
+  gcc_assert (LAMBDA_TYPE_P (closure_type));
+
+  tree lambda_expr = CLASSTYPE_LAMBDA_EXPR (closure_type);
+
+  tree lambda_object = build_lambda_object (lambda_expr);
+
+  return convert_out (ctx->preserve (lambda_object));
+}
+
+gcc_type
 plugin_start_new_union_type (cc1_plugin::connection *self,
 			     const char *name,
 			     enum gcc_cp_symbol_kind flags,
@@ -1313,7 +1444,7 @@ plugin_start_new_union_type (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (type));
 }
 
-int
+gcc_decl
 plugin_new_field (cc1_plugin::connection *,
 		  const char *field_name,
 		  gcc_type field_type_in,
@@ -1366,7 +1497,7 @@ plugin_new_field (cc1_plugin::connection *,
   DECL_CHAIN (decl) = TYPE_FIELDS (record_or_union_type);
   TYPE_FIELDS (record_or_union_type) = decl;
 
-  return 1;
+  return convert_out (decl);
 }
 
 int
@@ -1519,7 +1650,8 @@ plugin_add_function_default_args (cc1_plugin::connection *self,
     {
       gcc_assert (ndargs);
       tree deflt = convert_in (defaults->elements[i]);
-      gcc_assert (deflt);
+      if (!deflt)
+	deflt = error_mark_node;
       TREE_PURPOSE (ndargs) = deflt;
       ndargs = TREE_CHAIN (ndargs);
     }
@@ -1541,6 +1673,62 @@ plugin_add_function_default_args (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (result));
 }
 
+int
+plugin_set_deferred_function_default_args (cc1_plugin::connection *,
+					   gcc_decl function_in,
+					   const struct gcc_cp_function_args
+					   *defaults)
+{
+  tree function = convert_in (function_in);
+
+  gcc_assert (TREE_CODE (function) == FUNCTION_DECL);
+
+  if (!defaults || !defaults->n_elements)
+    return 1;
+
+  tree arg = FUNCTION_FIRST_USER_PARMTYPE (function);
+
+  for (int i = 0; i < defaults->n_elements; i++)
+    {
+      while (arg && TREE_PURPOSE (arg) != error_mark_node)
+	arg = TREE_CHAIN (arg);
+
+      if (!arg)
+	return 0;
+
+      TREE_PURPOSE (arg) = convert_in (defaults->elements[i]);
+      arg = TREE_CHAIN (arg);
+    }
+
+  return 1;
+}
+
+gcc_decl
+plugin_get_function_parameter_decl (cc1_plugin::connection *,
+				    gcc_decl function_in,
+				    int index)
+{
+  tree function = convert_in (function_in);
+
+  gcc_assert (TREE_CODE (function) == FUNCTION_DECL);
+
+  if (index == -1)
+    {
+      gcc_assert (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE);
+
+      return convert_out (DECL_ARGUMENTS (function));
+    }
+
+  gcc_assert (index >= 0);
+
+  tree args = FUNCTION_FIRST_USER_PARM (function);
+
+  for (int i = 0; args && i < index; i++)
+    args = DECL_CHAIN (args);
+
+  return convert_out (args);
+}
+
 gcc_type
 plugin_build_exception_spec_variant (cc1_plugin::connection *self,
 				     gcc_type function_type_in,
