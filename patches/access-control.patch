Bottom: 226367b25962d14cfe63759fa3dd4f69ff59ba7c
Top:    3b981f460974a986e47808ca71f3d39fe078b5cc
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-04-07 03:05:05 -0300

introduce access control flags and friend declarations


---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index d802cae..978c441 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -25,7 +25,7 @@
    namespace.  A namespace named NAME is created in the current scope,
    if needed.  */
 
-GCC_METHOD1 (int, push_namespace,
+GCC_METHOD1 (int /* bool */, push_namespace,
 	     const char *)	      /* Argument NAME.  */
 
 // FIXME: inline namespaces, anyone?
@@ -33,7 +33,7 @@ GCC_METHOD1 (int, push_namespace,
 /* Pop the namespace last entered with push_namespace, restoring the
    binding level in effect before the matching push_namespace.  */
 
-GCC_METHOD0 (int, pop_namespace)
+GCC_METHOD0 (int /* bool */, pop_namespace)
 
 /* Return the NAMESPACE_DECL, TYPE_DECL or FUNCTION_DECL of the
    current binding level.  */
@@ -183,6 +183,13 @@ GCC_METHOD7 (gcc_decl, new_decl,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
+/* Declare DECL as a friend of the current class scope.  DECL may be a
+   function or a class, be they template generics, template
+   specializations or not templates.  */
+
+GCC_METHOD1 (int /* bool */, new_friend,
+	     gcc_decl)		      /* Argument DECL.  */
+
 /* Return the type of a pointer to a given base type.  */
 
 GCC_METHOD1 (gcc_type, build_pointer_type,
@@ -212,7 +219,7 @@ GCC_METHOD2 (gcc_type, build_pointer_to_member_type,
    parameter list and declares a template function or a template class
    with the parameter list.  */
 
-GCC_METHOD0 (int, start_new_template_decl)
+GCC_METHOD0 (int /* bool */, start_new_template_decl)
 
 /* Return the declaration associated with the named type.  It is the
    declaration, rather than the type proper, that has to be passed as
@@ -409,8 +416,9 @@ GCC_METHOD5 (gcc_type, start_specialize_class_template,
    class NAME.  FILENAME and LINE_NUMBER specify the source location
    associated with the class.  */
 
-GCC_METHOD4 (gcc_type, start_new_class_type,
+GCC_METHOD5 (gcc_type, start_new_class_type,
 	     const char *,	      /* Argument NAME.  */
+	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
 	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
@@ -424,8 +432,9 @@ GCC_METHOD4 (gcc_type, start_new_class_type,
    NAME is the union name.  FILENAME and LINE_NUMBER specify its
    source location.  */
 
-GCC_METHOD3 (gcc_type, start_new_union_type,
+GCC_METHOD4 (gcc_type, start_new_union_type,
 	     const char *,	      /* Argument NAME.  */
+	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
@@ -436,8 +445,8 @@ GCC_METHOD3 (gcc_type, start_new_union_type,
 
 GCC_METHOD5 (int /* bool */, new_field,
 	     const char *,		   /* Argument FIELD_NAME.  */
+	     enum gcc_cp_symbol_kind,	   /* Argument FIELD_FLAGS.  */
 	     gcc_type,			   /* Argument FIELD_TYPE.  */
-	     enum gcc_cp_field_flags,	   /* Argument FIELD_FLAGS.  */
 	     unsigned long,		   /* Argument BITSIZE.  */
 	     unsigned long)		   /* Argument BITPOS.  */
 
@@ -458,7 +467,7 @@ GCC_METHOD1 (int /* bool */, finish_record_or_union,
 GCC_METHOD5 (gcc_type, start_new_enum_type,
 	     const char *,	      /* Argument NAME.  */
 	     gcc_type,		      /* Argument UNDERLYING_INT_TYPE. */
-	     int /* bool */,	      /* Argument SCOPED_ENUM_P.  */
+	     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 72649a1..e932a18 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-7
+  GCC_CP_FE_VERSION_0 = 0xffffffff-8
 };
 
 /* Qualifiers.  */
@@ -61,24 +61,6 @@ enum gcc_cp_ref_qualifiers {
   GCC_CP_REF_QUAL_RVALUE = 2
 };
 
-/* An array of types used for creating lists of base classes.  */
-
-struct gcc_vbase_array
-{
-  /* Number of elements.  */
-
-  int n_elements;
-
-  /* The base classes.  */
-
-  gcc_type *elements;
-
-  /* Indicate virtual base classes.
-     Take elements[i] as a virtual base class iff virtualp[i].  */
-
-  char /* bool */ *virtualp;
-};
-
 /* Opaque typedef for type declarations.  They are used for template
    arguments, defaults for type template parameters, and types used to
    build type-conversion expressions.  */
@@ -158,13 +140,38 @@ enum gcc_cp_symbol_kind
 
   GCC_CP_SYMBOL_LABEL,
 
-  /* A class, or, in a template parameter list scope, a declaration of
-     a template class, closing the parameter list.  */
+  /* A class (forward declared in new_decl, or introduced in
+     start_new_class_type), or, in a template parameter list scope, a
+     declaration of a template class, closing the parameter list.  */
 
   GCC_CP_SYMBOL_CLASS,
 
+  /* A union being introduced with start_new_union_type.  */
+  GCC_CP_SYMBOL_UNION,
+
+  /* An enumeration type being introduced with start_new_enum_type.  */
+  GCC_CP_SYMBOL_ENUM,
+
+  /* A nonstatic data member being introduced with new_field.  */
+  GCC_CP_SYMBOL_FIELD,
+
+  /* A base class in a gcc_vbase_array.  */
+  GCC_CP_SYMBOL_BASECLASS,
+
   GCC_CP_SYMBOL_MASK = 15,
-  GCC_CP_FLAG_BASE,
+
+  /* When defining a class member, at least one of the
+     GCC_CP_ACCESS_MASK bits must be set; when defining a namespace-
+     or union-scoped symbol, none of them must be set.  */
+
+  GCC_CP_ACCESS_PRIVATE,
+  GCC_CP_ACCESS_PUBLIC = GCC_CP_ACCESS_PRIVATE << 1,
+  GCC_CP_ACCESS_MASK = (GCC_CP_ACCESS_PUBLIC
+			       | GCC_CP_ACCESS_PRIVATE),
+  GCC_CP_ACCESS_PROTECTED = GCC_CP_ACCESS_MASK,
+  GCC_CP_ACCESS_NONE = 0,
+
+  GCC_CP_FLAG_BASE = GCC_CP_ACCESS_PRIVATE << 2,
 
   /* Flags to be used along with GCC_CP_SYMBOL_FUNCTION:  */
 
@@ -244,21 +251,96 @@ enum gcc_cp_symbol_kind
   GCC_CP_FLAG_MASK_VARIABLE = (((GCC_CP_FLAG_END_VARIABLE - 1) << 1)
 			       - GCC_CP_FLAG_BASE),
 
-  GCC_CP_FLAG_MASK = (GCC_CP_FLAG_MASK_FUNCTION | GCC_CP_FLAG_MASK_VARIABLE)
+  /* Flags to be used when defining nonstatic data members of classes
+     with new_field.  */
+
+  /* Use this when no flags are present.  */
+  GCC_CP_FLAG_FIELD_NOFLAG = 0,
+
+  /* This indicates the field is declared as mutable.  */
+  GCC_CP_FLAG_FIELD_MUTABLE = GCC_CP_FLAG_BASE,
+
+  GCC_CP_FLAG_END_FIELD,
+  GCC_CP_FLAG_MASK_FIELD = (((GCC_CP_FLAG_END_FIELD - 1) << 1)
+			    - GCC_CP_FLAG_BASE),
+
+  /* Flags to be used when defining an enum with
+     start_new_enum_type.  */
+
+  /* This indicates an enum type without any flags.  */
+  GCC_CP_FLAG_ENUM_NOFLAG = 0,
+
+  /* This indicates a scoped enum type.  */
+  GCC_CP_FLAG_ENUM_SCOPED = GCC_CP_FLAG_BASE,
+
+  GCC_CP_FLAG_END_ENUM,
+  GCC_CP_FLAG_MASK_ENUM = (((GCC_CP_FLAG_END_ENUM - 1) << 1)
+			       - GCC_CP_FLAG_BASE),
+
+
+  /* Flags to be used when introducing a class with
+     start_new_class_type, or a class template with new_decl.  */
+
+  /* This indicates an enum type without any flags.  */
+  GCC_CP_FLAG_CLASS_NOFLAG = 0,
+
+  /* This indicates the class is actually a struct.  This has no
+     effect whatsoever on access control in this interface, since all
+     class members must have explicit access control bits set, but it
+     may affect error messages.  */
+  GCC_CP_FLAG_CLASS_IS_STRUCT = GCC_CP_FLAG_BASE,
+
+  GCC_CP_FLAG_END_CLASS,
+  GCC_CP_FLAG_MASK_CLASS = (((GCC_CP_FLAG_END_CLASS - 1) << 1)
+			       - GCC_CP_FLAG_BASE),
+
+
+  /* Flags to be used when introducing a virtual base class in a
+     gcc_vbase_array.  */
+
+  /* This indicates an enum type without any flags.  */
+  GCC_CP_FLAG_BASECLASS_NOFLAG = 0,
+
+  /* This indicates the class is actually a struct.  This has no
+     effect whatsoever on access control in this interface, since all
+     class members must have explicit access control bits set, but it
+     may affect error messages.  */
+  GCC_CP_FLAG_BASECLASS_VIRTUAL = GCC_CP_FLAG_BASE,
+
+  GCC_CP_FLAG_END_BASECLASS,
+  GCC_CP_FLAG_MASK_BASECLASS = (((GCC_CP_FLAG_END_BASECLASS - 1) << 1)
+				- GCC_CP_FLAG_BASE),
+
+
+  GCC_CP_FLAG_MASK = (GCC_CP_FLAG_MASK_FUNCTION
+		      | GCC_CP_FLAG_MASK_VARIABLE
+		      | GCC_CP_FLAG_MASK_FIELD
+		      | GCC_CP_FLAG_MASK_ENUM
+		      | GCC_CP_FLAG_MASK_CLASS
+		      | GCC_CP_FLAG_MASK_BASECLASS
+		      )
 };
 
-/* This bitfield names flags that can be associated with non-static
-   data members of structs and classes.  */
 
-enum gcc_cp_field_flags
+/* An array of types used for creating lists of base classes.  */
+
+struct gcc_vbase_array
 {
-  /* Use this when no flags are present.  */
-  GCC_CP_FIELD_NORMAL = 0,
+  /* Number of elements.  */
 
-  /* This indicates the field is declared as mutable.  */
-  GCC_CP_FIELD_MUTABLE = 1
+  int n_elements;
+
+  /* The base classes.  */
+
+  gcc_type *elements;
+
+  /* Flags for each base class.  Used to indicate access control and
+     virtualness.  */
+
+  enum gcc_cp_symbol_kind *flags;
 };
 
+
 /* This enumerates the types of symbols that GCC might request from
    GDB.  */
 
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 3808017..d91f393 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -262,6 +262,11 @@ static void
 plugin_pragma_user_expression (cpp_reader *)
 {
   cp_binding_oracle = plugin_binding_oracle;
+
+  /* Make the function containing the user expression a global
+     friend, so as to bypass access controls in it.  */
+  if (at_function_scope_p ())
+    add_to_global_friend_list (current_function_decl);
 }
 
 static void
@@ -395,37 +400,31 @@ safe_pushdecl_maybe_friend (tree decl, bool is_friend)
 
 
 int
-plugin_push_namespace (cc1_plugin::connection *self,
+plugin_push_namespace (cc1_plugin::connection *,
 		       const char *name)
 {
-  (void)self;
-
   if (name && !*name)
     push_to_top_level ();
   else
     push_namespace (name ? get_identifier (name) : NULL);
 
-  return 0;
+  return 1;
 }
 
 int
-plugin_pop_namespace (cc1_plugin::connection *self)
+plugin_pop_namespace (cc1_plugin::connection *)
 {
-  (void)self;
-
   if (toplevel_bindings_p () && current_namespace == global_namespace)
     pop_from_top_level ();
   else
     pop_namespace ();
 
-  return 0;
+  return 1;
 }
 
 gcc_decl
-plugin_get_current_binding_level (cc1_plugin::connection *self)
+plugin_get_current_binding_level (cc1_plugin::connection *)
 {
-  (void)self;
-
   tree decl;
 
   if (at_namespace_scope_p ())
@@ -441,6 +440,29 @@ plugin_get_current_binding_level (cc1_plugin::connection *self)
 }
 
 
+static inline void
+set_access_flags (tree decl, enum gcc_cp_symbol_kind flags)
+{
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !DECL_CLASS_SCOPE_P (decl));
+
+  switch (flags & GCC_CP_ACCESS_MASK)
+    {
+    case GCC_CP_ACCESS_PRIVATE:
+      TREE_PRIVATE (decl) = true;
+      break;
+
+    case GCC_CP_ACCESS_PROTECTED:
+      TREE_PROTECTED (decl) = true;
+      break;
+
+    case GCC_CP_ACCESS_PUBLIC:
+      break;
+
+    default:
+      break;
+    }
+}
+
 gcc_decl
 plugin_new_decl (cc1_plugin::connection *self,
 		 const char *name,
@@ -452,18 +474,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 		 unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
-  { // FIXME in gdb:
-    char *nname = (char*)strrchr (name, ':');
-    if (nname)
-      name = nname + 1;
-    char *nameend = (char*)strchr (name, '(');
-    if (nameend)
-      {
-	*nameend = 0;
-	name = strdupa (name);
-	*nameend = '(';
-      }
-  }
+  gcc_assert (!strchr (name, ':')); // FIXME: this can go eventually.
   tree identifier = get_identifier (name);
   enum tree_code code;
   tree decl;
@@ -509,6 +520,8 @@ plugin_new_decl (cc1_plugin::connection *self,
   bool ctor = false, dtor = false, assop = false;
   tree_code opcode = ERROR_MARK;
 
+  gcc_assert (!(sym_kind & GCC_CP_ACCESS_MASK) == !class_member_p);
+
   if (code == FUNCTION_DECL)
     {
       if (sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION)
@@ -794,6 +807,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 	      fns = CLASSTYPE_DESTRUCTORS (current_class_type);
 	    }
 	  DECL_CONTEXT (decl) = FROB_CONTEXT (current_class_type);
+	  set_access_flags (decl, sym_kind);
 	  maybe_retrofit_in_chrg (decl);
 	  for (; fns; fns = OVL_NEXT (fns))
 	    {
@@ -888,6 +902,8 @@ plugin_new_decl (cc1_plugin::connection *self,
   else if (at_namespace_scope_p ())
     DECL_CONTEXT (decl) = FROB_CONTEXT (current_decl_namespace ());
 
+  set_access_flags (decl, sym_kind);
+
   if (sym_kind != GCC_CP_SYMBOL_TYPEDEF)
     {
       decl_addr_value value;
@@ -927,6 +943,27 @@ plugin_new_decl (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (decl));
 }
 
+int
+plugin_new_friend (cc1_plugin::connection * /* self */,
+		   gcc_decl decl_in)
+{
+  tree decl = convert_in (decl_in);
+
+  gcc_assert (at_class_scope_p ());
+
+  /* FIXME: is this enough to support template friend declarations?  */
+
+  if (TYPE_P (decl))
+    make_friend_type (current_class_type, decl, true);
+  else
+    {
+      DECL_FRIEND_P (decl) = true;
+      add_friend (current_class_type, decl, true);
+    }
+
+  return 1;
+}
+
 gcc_type
 plugin_build_pointer_type (cc1_plugin::connection *,
 			   gcc_type base_type)
@@ -969,9 +1006,32 @@ start_class_def (tree type,
     {
       for (int i = 0; i < base_classes->n_elements; i++)
 	{
+	  tree access;
+
+	  gcc_assert ((base_classes->flags[i] & GCC_CP_SYMBOL_MASK)
+		      == GCC_CP_SYMBOL_BASECLASS);
+
+	  switch (base_classes->flags[i] & GCC_CP_ACCESS_MASK)
+	    {
+	    case GCC_CP_ACCESS_PRIVATE:
+	      access = ridpointers[(int)RID_PRIVATE];
+	      break;
+
+	    case GCC_CP_ACCESS_PROTECTED:
+	      access = ridpointers[(int)RID_PROTECTED];
+	      break;
+
+	    case GCC_CP_ACCESS_PUBLIC:
+	      access = ridpointers[(int)RID_PUBLIC];
+	      break;
+
+	    default:
+	      gcc_unreachable ();
+	    }
+
 	  tree base = finish_base_specifier
-	    (convert_in (base_classes->elements[i]),
-	     access_default_node, base_classes->virtualp[i]);
+	    (convert_in (base_classes->elements[i]), access,
+	     (base_classes->flags[i] & GCC_CP_FLAG_BASECLASS_VIRTUAL) != 0);
 	  TREE_CHAIN (base) = bases;
 	  bases = base;
 	}
@@ -1001,15 +1061,27 @@ build_named_class_type (enum tree_code code,
 gcc_type
 plugin_start_new_class_type (cc1_plugin::connection *self,
 			     const char *name,
+			     enum gcc_cp_symbol_kind flags,
 			     const gcc_vbase_array *base_classes,
 			     const char *filename,
 			     unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
 
+  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_CLASS);
+  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
+			  | GCC_CP_FLAG_MASK_CLASS))) == 0);
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
+
   tree type = build_named_class_type (RECORD_TYPE, name, base_classes,
 				      ctx->get_source_location (filename,
 								line_number));
+  tree decl = TYPE_NAME (type);
+
+  set_access_flags (decl, flags);
+
+  if (!(flags & GCC_CP_FLAG_CLASS_IS_STRUCT))
+    CLASSTYPE_DECLARED_CLASS (type) = true;
 
   return convert_out (ctx->preserve (type));
 }
@@ -1017,14 +1089,22 @@ plugin_start_new_class_type (cc1_plugin::connection *self,
 gcc_type
 plugin_start_new_union_type (cc1_plugin::connection *self,
 			     const char *name,
+			     enum gcc_cp_symbol_kind flags,
 			     const char *filename,
 			     unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
 
+  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_UNION);
+  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK))) == 0);
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
+
   tree type = build_named_class_type (UNION_TYPE, name, NULL,
 				      ctx->get_source_location (filename,
 								line_number));
+  tree decl = TYPE_NAME (type);
+
+  set_access_flags (decl, flags);
 
   return convert_out (ctx->preserve (type));
 }
@@ -1032,15 +1112,20 @@ plugin_start_new_union_type (cc1_plugin::connection *self,
 int
 plugin_new_field (cc1_plugin::connection *,
 		  const char *field_name,
+		  enum gcc_cp_symbol_kind flags,
 		  gcc_type field_type_in,
-		  enum gcc_cp_field_flags field_flags,
 		  unsigned long bitsize,
 		  unsigned long bitpos)
 {
   tree record_or_union_type = current_class_type;
   tree field_type = convert_in (field_type_in);
 
+  gcc_assert (at_class_scope_p ());
   gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (record_or_union_type)));
+  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_FIELD);
+  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
+			  | GCC_CP_FLAG_MASK_FIELD))) == 0);
+  gcc_assert ((flags & GCC_CP_ACCESS_MASK));
 
   /* Note that gdb does not preserve the location of field decls, so
      we can't provide a decent location here.  */
@@ -1048,7 +1133,9 @@ plugin_new_field (cc1_plugin::connection *,
 			  get_identifier (field_name), field_type);
   DECL_FIELD_CONTEXT (decl) = record_or_union_type;
 
-  if ((field_flags & GCC_CP_FIELD_MUTABLE) != 0)
+  set_access_flags (decl, flags);
+
+  if ((flags & GCC_CP_FLAG_FIELD_MUTABLE) != 0)
     DECL_MUTABLE_P (decl) = 1;
 
   if (TREE_CODE (field_type) == INTEGER_TYPE
@@ -1101,13 +1188,18 @@ gcc_type
 plugin_start_new_enum_type (cc1_plugin::connection *self,
 			    const char *name,
 			    gcc_type underlying_int_type_in,
-			    int scoped_enum_p,
+			    enum gcc_cp_symbol_kind flags,
 			    const char *filename,
 			    unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   tree underlying_int_type = convert_in (underlying_int_type_in);
 
+  gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_ENUM);
+  gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
+			  | GCC_CP_FLAG_MASK_ENUM))) == 0);
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
+
   if (underlying_int_type == error_mark_node)
     return convert_out (error_mark_node);
 
@@ -1118,7 +1210,7 @@ plugin_start_new_enum_type (cc1_plugin::connection *self,
   tree type = start_enum (id, NULL_TREE,
 			  underlying_int_type,
 			  /* attributes = */ NULL_TREE,
-			  !!scoped_enum_p, &is_new_type);
+			  !!(flags & GCC_CP_FLAG_ENUM_SCOPED), &is_new_type);
 
   gcc_assert (is_new_type);
 
@@ -1129,6 +1221,8 @@ plugin_start_new_enum_type (cc1_plugin::connection *self,
 
   safe_pushtag (DECL_NAME (type_decl), type, ts_current);
 
+  set_access_flags (type_decl, flags);
+
   return convert_out (ctx->preserve (type));
 }
 
@@ -1337,7 +1431,7 @@ plugin_start_new_template_decl (cc1_plugin::connection *self ATTRIBUTE_UNUSED)
 
   TP_PARM_LIST = NULL_TREE;
 
-  return 0;
+  return 1;
 }
 
 gcc_typedecl
diff --git a/libcc1/marshall-cp.hh b/libcc1/marshall-cp.hh
index 7ee2311..87de7f9 100644
--- a/libcc1/marshall-cp.hh
+++ b/libcc1/marshall-cp.hh
@@ -36,16 +36,6 @@ namespace cc1_plugin
   }
 
   status
-  unmarshall (connection *conn, enum gcc_cp_field_flags *result)
-  {
-    protocol_int p;
-    if (!unmarshall_intlike (conn, &p))
-      return FAIL;
-    *result = (enum gcc_cp_field_flags) p;
-    return OK;
-  }
-
-  status
   unmarshall (connection *conn, enum gcc_cp_oracle_request *result)
   {
     protocol_int p;
@@ -96,8 +86,8 @@ namespace cc1_plugin
 			       a->elements))
       return FAIL;
 
-    return marshall_array_elmts (conn, len * sizeof (a->virtualp[0]),
-				 a->virtualp);
+    return marshall_array_elmts (conn, len * sizeof (a->flags[0]),
+				 a->flags);
   }
 
   // Read a gcc_vbase_array marker, followed by a gcc_vbase_array.  The
@@ -131,13 +121,13 @@ namespace cc1_plugin
 	return FAIL;
       }
 
-    gva->virtualp = new char[len];
+    gva->flags = new enum gcc_cp_symbol_kind[len];
 
     if (!unmarshall_array_elmts (conn,
-				 len * sizeof (gva->virtualp[0]),
-				 gva->virtualp))
+				 len * sizeof (gva->flags[0]),
+				 gva->flags))
       {
-	delete[] gva->virtualp;
+	delete[] gva->flags;
 	delete[] gva->elements;
 	delete gva;
 	return FAIL;
diff --git a/libcc1/rpc.hh b/libcc1/rpc.hh
index c8f1b4f..93d779ca 100644
--- a/libcc1/rpc.hh
+++ b/libcc1/rpc.hh
@@ -138,7 +138,7 @@ namespace cc1_plugin
       // But, it is in code shared with gdb and cannot.
       if (m_object != NULL)
 	{
-	  delete[] m_object->virtualp;
+	  delete[] m_object->flags;
 	  delete[] m_object->elements;
 	}
       delete m_object;
