Bottom: 2b0710cae974d70ae245cc260cbe77377d14d5a7
Top:    dc7515afd3bafeb8189262f26559c562c443a6ae
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-17 22:49:44 -0300

introduce call exprs

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 6536597..d9e4289 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -521,6 +521,19 @@ GCC_METHOD3 (gcc_expr, type_value_expr,
 	     gcc_type,		  /* Argument OPERAND1.  */
 	     gcc_expr)		  /* Argument OPERAND2.  */
 
+/* Return a call expression that calls CALLABLE with arguments ARGS.
+   CALLABLE may be a function, a callable object, a pointer to
+   function, an unresolved value expression, an unresolved overload
+   set, an object expression combined with a member function overload
+   set or a pointer-to-member.  If QUALIFIED_P, CALLABLE will be
+   interpreted as a qualified name, preventing virtual function
+   dispatch.  */
+
+GCC_METHOD3 (gcc_expr, call_expr,
+	     gcc_expr,			      /* Argument CALLABLE.  */
+	     int /* bool */,		  /* Argument QUALIFIED_P.  */
+	     const struct gcc_cp_function_args *) /* Argument ARGS.  */
+	     
 /* FIXME: function call operations?  ctor/dtor?  new/delete?  */
 
 /* Return the type of the gcc_expr OPERAND.
@@ -534,6 +547,7 @@ GCC_METHOD3 (gcc_expr, type_value_expr,
 GCC_METHOD1 (gcc_type, expr_type,
 	     gcc_expr)		  /* Argument OPERAND.  */
 
+
 /* Introduce a specialization of a template function.
 
    TEMPLATE_DECL is the template function, and TARGS are the arguments
@@ -659,8 +673,8 @@ GCC_METHOD3 (gcc_type, build_function_type,
    the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0). */
 
 GCC_METHOD2 (gcc_type, add_function_default_args,
-	     gcc_type,			   /* Argument FUNCTION_TYPE.  */
-	     const struct gcc_cp_function_default_args *)/* DEFAULTS.  */
+	     gcc_type,			     /* Argument FUNCTION_TYPE.  */
+	     const struct gcc_cp_function_args *) /* Argument DEFAULTS.  */
 
 /* Create a variant of a function type with an exception
    specification.  FUNCTION_TYPE is a function or method type.
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 3710a3a8..de467a3 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-12
+  GCC_CP_FE_VERSION_0 = 0xffffffff-13
 };
 
 /* Qualifiers.  */
@@ -101,15 +101,15 @@ struct gcc_cp_template_args
   gcc_cp_template_arg *elements;
 };
 
-/* An array of default function arguments.  */
+/* An array of (default) function arguments.  */
 
-struct gcc_cp_function_default_args
+struct gcc_cp_function_args
 {
   /* Number of elements.  */
 
   int n_elements;
 
-  /* The default values.  */
+  /* The (default) values for each argument.  */
 
   gcc_expr *elements;
 };
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 59586a80..1486948 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1485,7 +1485,7 @@ plugin_build_function_type (cc1_plugin::connection *self,
 gcc_type
 plugin_add_function_default_args (cc1_plugin::connection *self,
 				  gcc_type function_type_in,
-				  const struct gcc_cp_function_default_args *defaults)
+				  const struct gcc_cp_function_args *defaults)
 {
   tree function_type = convert_in (function_type_in);
 
@@ -2140,7 +2140,10 @@ plugin_unary_value_expr (cc1_plugin::connection *self,
     case CHARS2 ('n', 't'): // operator !
       opcode = TRUTH_NOT_EXPR;
       break;
-      /* FIXME: __real__, __imag__.  */
+      /* FIXME: __real__, __imag__, (global-scope) delete, delete[],
+	 preinc, predec, noexcept,
+	 non-type (and type) typeid, sizeof, alignof,
+	 sizeof...(pack), pack... (expansion), throw (rethrow?).  */
     case CHARS2 ('p', 'p'): // operator ++
     case CHARS2 ('m', 'm'): // operator --
     default:
@@ -2269,7 +2272,8 @@ plugin_unary_type_expr (cc1_plugin::connection *self,
   tree_code opcode = ERROR_MARK;
   switch (CHARS2 (unary_op[0], unary_op[1]))
     {
-      /* FIXME: implement sizeof, alignof, ...  */
+      /* FIXME: implement sizeof, alignof, new, new[] (but how about
+	 placement new args, ctor arguments, global scope?), ...  */
     default:
       gcc_unreachable ();
     }
@@ -2293,7 +2297,8 @@ plugin_type_value_expr (cc1_plugin::connection *self,
 #endif
   switch (CHARS2 (binary_op[0], binary_op[1]))
     {
-      /* FIXME: implement type casts, ...  */
+      /* FIXME: implement type casts; conversions taking argument
+	 lists or braced initializers?  */
     default:
       gcc_unreachable ();
     }
@@ -2303,6 +2308,69 @@ plugin_type_value_expr (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (val));
 }
 
+gcc_expr
+plugin_call_expr (cc1_plugin::connection *self,
+		  gcc_expr callable_in, int qualified_p,
+		  const struct gcc_cp_function_args *args_in)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree callable = convert_in (callable_in);
+  tree call_expr;
+
+  vec<tree, va_gc> *args = make_tree_vector ();
+  for (int i = 0; i < args_in->n_elements; i++)
+    vec_safe_push (args, convert_in (args_in->elements[i]));
+
+  bool koenig_p = false;
+  if (!qualified_p && !args->is_empty ())
+    {
+      if (identifier_p (callable))
+	koenig_p = true;
+      else if (is_overloaded_fn (callable))
+	{
+	  tree fn = get_first_fn (callable);
+	  fn = STRIP_TEMPLATE (fn);
+
+	  if (!DECL_FUNCTION_MEMBER_P (fn)
+	      && !DECL_LOCAL_FUNCTION_P (fn))
+	    koenig_p = true;
+	}
+    }
+
+  if (koenig_p && !any_type_dependent_arguments_p (args))
+    callable = perform_koenig_lookup (callable, args, tf_none);
+
+  if (TREE_CODE (callable) == COMPONENT_REF)
+    {
+      tree object = TREE_OPERAND (callable, 0);
+      tree memfn = TREE_OPERAND (callable, 1);
+
+      if (type_dependent_expression_p (object)
+	  || (!BASELINK_P (memfn) && TREE_CODE (memfn) != FIELD_DECL)
+	  || type_dependent_expression_p (memfn)
+	  || any_type_dependent_arguments_p (args))
+	call_expr = build_nt_call_vec (callable, args);
+      else if (BASELINK_P (memfn))
+	call_expr = build_new_method_call (object, memfn, &args, NULL_TREE,
+					   qualified_p
+					   ? LOOKUP_NORMAL|LOOKUP_NONVIRTUAL
+					   : LOOKUP_NORMAL,
+					   NULL, tf_none);
+      else
+	call_expr = finish_call_expr (callable, &args, false, false, tf_none);
+    }
+  else if (TREE_CODE (callable) == OFFSET_REF
+	   || TREE_CODE (callable) == MEMBER_REF
+	   || TREE_CODE (callable) == DOTSTAR_EXPR)
+    call_expr = build_offset_ref_call_from_tree (callable, &args, tf_none);
+  else
+    call_expr = finish_call_expr (callable, &args,
+				  !!qualified_p, koenig_p, tf_none);
+
+  release_tree_vector (args);
+  return convert_out (ctx->preserve (call_expr));
+}
+
 gcc_type
 plugin_expr_type (cc1_plugin::connection *,
 		  gcc_expr operand)
diff --git a/libcc1/marshall-cp.hh b/libcc1/marshall-cp.hh
index 87de7f9..a7abaa2 100644
--- a/libcc1/marshall-cp.hh
+++ b/libcc1/marshall-cp.hh
@@ -209,9 +209,9 @@ namespace cc1_plugin
     return OK;
   }
 
-  // Send a gcc_cp_function_default_args marker followed by the array.
+  // Send a gcc_cp_function_args marker followed by the array.
   status
-  marshall (connection *conn, const gcc_cp_function_default_args *a)
+  marshall (connection *conn, const gcc_cp_function_args *a)
   {
     size_t len;
 
@@ -230,12 +230,12 @@ namespace cc1_plugin
 				 a->elements);
   }
 
-  // Read a gcc_cp_function_default_args marker, followed by a
-  // gcc_cp_function_default_args.  The resulting array must be freed
+  // Read a gcc_cp_function_args marker, followed by a
+  // gcc_cp_function_args.  The resulting array must be freed
   // by the caller, using 'delete[]' on elements and virtualp, and
   // 'delete' on the array object itself.
   status
-  unmarshall (connection *conn, struct gcc_cp_function_default_args **result)
+  unmarshall (connection *conn, struct gcc_cp_function_args **result)
   {
     size_t len;
 
@@ -248,7 +248,7 @@ namespace cc1_plugin
 	return OK;
       }
 
-    struct gcc_cp_function_default_args *gva = new gcc_cp_function_default_args;
+    struct gcc_cp_function_args *gva = new gcc_cp_function_args;
 
     gva->n_elements = len;
     gva->elements = new gcc_expr[len];
diff --git a/libcc1/rpc.hh b/libcc1/rpc.hh
index 93d779ca..aafbb83 100644
--- a/libcc1/rpc.hh
+++ b/libcc1/rpc.hh
@@ -200,9 +200,9 @@ namespace cc1_plugin
     argument_wrapper &operator= (const argument_wrapper &);
   };
 
-  // Specialization for gcc_cp_function_default_args.
+  // Specialization for gcc_cp_function_args.
   template<>
-  class argument_wrapper<const gcc_cp_function_default_args *>
+  class argument_wrapper<const gcc_cp_function_args *>
   {
   public:
     argument_wrapper () : m_object (NULL) { }
@@ -217,7 +217,7 @@ namespace cc1_plugin
       delete m_object;
     }
 
-    operator const gcc_cp_function_default_args * () const
+    operator const gcc_cp_function_args * () const
     {
       return m_object;
     }
@@ -229,7 +229,7 @@ namespace cc1_plugin
 
   private:
 
-    gcc_cp_function_default_args *m_object;
+    gcc_cp_function_args *m_object;
 
     // No copying or assignment allowed.
     argument_wrapper (const argument_wrapper &);
