Bottom: 79b758af6225a9f70dfe7287a1136f300ff1f6b2
Top:    fe799671cbc4122d5b2083237fef07f04480c9f7
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2015-10-29 00:44:30 -0200

API extensions for special member functions

Bump API version to -3.

Change virtual member functions from a kind of its own to a flag for
regular functions.

Introduce support for overloaded operators, constructors,
destructores, pure and final virtual member functions, defaulted and
deleted member functions, explicit constructors and conversion
operators, and constexpr variables and data members.


---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 7471581..4a6fb7f 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -60,18 +60,119 @@ GCC_METHOD0 (gcc_decl, get_current_binding_level)
    Note that, since access controls are disabled, we have no means to
    express private, protected and public.
 
-   We have no means to introduce friend declarations, but since we
-   disable access control, they make no difference whatsoever.
+   There are various flags that can be set in SYM_KIND to specify
+   additional semantics.  Look for GCC_CP_FLAGs in the definition of
+   enum gcc_cp_symbol_kind in gcc-cp-interface.h.
+
+   In order to define member functions, pass GCC_CP_SYMBOL_FUNCTION in
+   SYM_KIND, and a function_type for static member functions or a
+   method type for non-static member functions, including constructors
+   and destructors.  Use build_function_type to create a function
+   type; for a method type, start by creating a function type without
+   any compiler-introduced artificial arguments (the implicit this
+   pointer, and the __in_chrg added to constructors and destructors,
+   and __vtt_parm added to the former), and then use build_method_type
+   to create the method type out of the class type and the function
+   type.
+
+   For constructors, destructors and operator functions, set
+   GCC_CP_FLAG_SPECIAL_FUNCTION in SYM_KIND, in addition to any other
+   applicable flags, and pass as NAME a string starting with the
+   two-character mangling for the constructor or destructor variant
+   (C1, C2, D0, D1, or D2, see below) or for the operator name: "ps"
+   for unary plus, "mL" for multiply and assign, *=; etc.  Use "cv"
+   for type converstion operators (the target type portion may be
+   omitted, as it is taken from the return type in SYM_TYPE).  For
+   operator"", use "li" followed by the identifier (the mangled name
+   mandates digits specifying the length of the identifier; if
+   present, they determine the end of the identifier, otherwise, the
+   identifier extents to the end of the string, so that "li3_Kme" and
+   "li_Km" are equivalent).
+
+   Constructors and destructors need special care, since for each
+   constructor prototype defined in the sources, two symbols are
+   defined in the object code: C1 initializes an instance of the class
+   (rather than of derived classes), including virtual base classes,
+   whereas C2 initializes a sub-object (of the given class type) of an
+   instance of some derived class (or a full object that doesn't have
+   any virtual base classes); for the destructor of each class, there
+   may be up to three variants (not counting virtual thunks): D0 and
+   D1 destruct an instance of the class, including virtual base
+   classes, but only the former calls operator delete to release the
+   object's storage at the end; D2 destructs a sub-object (of the
+   given class type) of an instance of a derived class (or a full
+   object that doesn't have any virtual base classes).  new_decl
+   expects to be called once for each constructor and destructor
+   variant; the first time it sees a constructor or destructor with a
+   given prototype, it will create the member declaration and all
+   appropriate variants; then, and at subsequent calls for other
+   variants, it will select the artificial clone declaration for the
+   chosen variant, and set up the address or substitution name for
+   that variant only.
+
+   NAMEs for GCC_CP_FLAG_SPECIAL_FUNCTION:
+
+     NAME    meaning
+     C1      in-charge constructor
+     C2      not-in-charge constructor
+     D0      deleting destructor
+     D1      in-charge destructor
+     D2      not-in-charge destructor
+     nw      operator new
+     na      operator new[]
+     dl      operator delete
+     da      operator delete[]
+     ps      operator + (unary)
+     ng      operator - (unary)
+     ad      operator & (unary)
+     de      operator * (unary)
+     co      operator ~
+     pl      operator +
+     mi      operator -
+     ml      operator *
+     dv      operator /
+     rm      operator %
+     an      operator &
+     or      operator |
+     eo      operator ^
+     aS      operator =
+     pL      operator +=
+     mI      operator -=
+     mL      operator *=
+     dV      operator /=
+     rM      operator %=
+     aN      operator &=
+     oR      operator |=
+     eO      operator ^=
+     ls      operator <<
+     rs      operator >>
+     lS      operator <<=
+     rS      operator >>=
+     eq      operator ==
+     ne      operator !=
+     lt      operator <
+     gt      operator >
+     le      operator <=
+     ge      operator >=
+     nt      operator !
+     aa      operator &&
+     oo      operator ||
+     pp      operator ++
+     mm      operator --
+     cm      operator ,
+     pm      operator ->*
+     pt      operator ->
+     cl      operator ()
+     ix      operator []
+     qu      operator ?
+     cv      operator <T> (conversion operator)
+     li<id>  operator "" <id>
 
    FIXME: we would benefit from a gcc_decl argument, to be able to
    introduce using declarations, using directives and namespace
    aliases.
 
-   FIXME: How about override and final virtual functions; =delete and
-   =default ctor, dtor and copy-assignment declarations; explicit
-   ctors and conversion operators; thread_local variables; other
-   attributes?  Do we need an extra flags parameter, or just
-   additional gcc_cp_symbol_kinds?  */
+   FIXME: How about attributes; static_assert; lambdas?  */
 
 GCC_METHOD7 (gcc_decl, new_decl,
 	     const char *,	      /* Argument NAME.  */
@@ -183,7 +284,9 @@ GCC_METHOD1 (int /* bool */, finish_enum_type,
 /* Create a new function type.  RETURN_TYPE is the type returned by
    the function, and ARGUMENT_TYPES is a vector, of length NARGS, of
    the argument types.  IS_VARARGS is true if the function is
-   varargs.  */
+   varargs.
+
+   FIXME: default arguments?  */
 
 GCC_METHOD3 (gcc_type, build_function_type,
 	     gcc_type,			   /* Argument RETURN_TYPE.  */
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index cb297b6..873279b 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-2
+  GCC_CP_FE_VERSION_0 = 0xffffffff-3
 };
 
 /* Qualifiers.  */
@@ -99,12 +99,85 @@ enum gcc_cp_symbol_kind
 
   GCC_CP_SYMBOL_LABEL,
 
-  /* A virtual member function.  */
+  GCC_CP_SYMBOL_MASK = 15,
+  GCC_CP_FLAG_BASE,
 
-  GCC_CP_SYMBOL_VIRTUAL_FUNCTION
+  /* Flags to be used along with GCC_CP_SYMBOL_FUNCTION:  */
 
-  // FIXME: should we have separate symbol kinds for operator
-  // functions, ctors, dtors, vtables, rtti, etc?
+  /* This flag should be set for constructors, destructors and
+     operators.  */
+  GCC_CP_FLAG_SPECIAL_FUNCTION = GCC_CP_FLAG_BASE,
+
+  /* We intentionally cannot express inline, constexpr, friend or
+     virtual override for functions.  We can't inline or
+     constexpr-replace without a source-level body.  Since we disable
+     access control, friend is meaningless.  The override keyword is
+     only meaningless within the definition of the containing
+     class.  */
+
+  /* This indicates a "virtual" member function, explicitly or
+     implicitly (due to a virtual function with the same name and
+     prototype in a base class) declared as such.  */
+  GCC_CP_FLAG_VIRTUAL_FUNCTION = GCC_CP_FLAG_BASE << 1,
+
+  /* This indicates a pure virtual member function, i.e., one that is
+     declared with "= 0", even if a body is provided in the
+     definition.  */
+  GCC_CP_FLAG_PURE_VIRTUAL_FUNCTION = GCC_CP_FLAG_BASE << 2,
+
+  /* This indicates a "final" virtual member function.  */
+  GCC_CP_FLAG_FINAL_VIRTUAL_FUNCTION = GCC_CP_FLAG_BASE << 3,
+
+  /* This indicates a special member function should have its default
+     implementation.  This either means the function declaration
+     contains the "= default" tokens, or that the member function was
+     implicitly generated by the compiler, although the latter use is
+     discouraged: just let the compiler implicitly introduce it.
+
+     A member function defaulted after its first declaration has
+     slightly different ABI implications from one implicitly generated
+     or explicitly defaulted at the declaration (and definition)
+     point.  To avoid silent (possibly harmless) violation of the one
+     definition rule, it is recommended that this flag not be used for
+     such functions, and that the address of the definition be
+     supplied instead.  */
+  GCC_CP_FLAG_DEFAULTED_FUNCTION = GCC_CP_FLAG_BASE << 4,
+
+  /* This indicates a deleted member function, i.e., one that has been
+     defined as "= delete" at its declaration point, or one that has
+     been implicitly defined as deleted (with or without an explicit
+     "= default" definition).
+
+     This should not be used for implicitly-declared member functions
+     that resolve to deleted definitions, as it may affect the
+     implicit declaration of other member functions.  */
+  GCC_CP_FLAG_DELETED_FUNCTION = GCC_CP_FLAG_BASE << 5,
+
+  /* This indicates a constructor or type-conversion operator declared
+     as "explicit".  */
+
+  GCC_CP_FLAG_EXPLICIT_FUNCTION = GCC_CP_FLAG_BASE << 6,
+
+  GCC_CP_FLAG_END_FUNCTION,
+  GCC_CP_FLAG_MASK_FUNCTION = (((GCC_CP_FLAG_END_FUNCTION - 1) << 1)
+			       - GCC_CP_FLAG_BASE),
+
+  /* Flags to be used along with GCC_CP_SYMBOL_VARIABLE:  */
+
+  /* This indicates a variable declared as "constexpr".  */
+
+  GCC_CP_FLAG_CONSTEXPR_VARIABLE = GCC_CP_FLAG_BASE,
+
+  /* This indicates a variable declared as "thread_local".  ??? What
+     should the ADDRESS be?  */
+
+  GCC_CP_FLAG_THREAD_LOCAL_VARIABLE = GCC_CP_FLAG_BASE << 1,
+
+  GCC_CP_FLAG_END_VARIABLE,
+  GCC_CP_FLAG_MASK_VARIABLE = (((GCC_CP_FLAG_END_VARIABLE - 1) << 1)
+			       - GCC_CP_FLAG_BASE),
+
+  GCC_CP_FLAG_MASK = (GCC_CP_FLAG_MASK_FUNCTION | GCC_CP_FLAG_MASK_VARIABLE)
 };
 
 /* This enumerates the types of symbols that GCC might request from
