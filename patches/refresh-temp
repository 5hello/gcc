Bottom: b3c1d7a6f3a6760afdb78409535dd2c442776075
Top:    cee1587b3346bc4d0b8bda99f068516bafdfd361
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-13 20:34:13 -0300

Refresh of dependent-special-funcs.patch

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 6ba208c..d149847 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -429,19 +429,26 @@ GCC_METHOD2 (gcc_type, new_dependent_typespec,
 	     gcc_utempl,		   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
-/* Build a template-dependent value expression (e.g., T::val or
-   T::template mtf<X>, or unqualified f or template tf<X>).
-   ENCLOSING_TYPE should be the template-dependent nested name
-   specifier (e.g., T) or NULL for unqualified names, ID should be the
-   name of the member of the ENCLOSING_TYPE (e.g., val or mtf) or
-   unqualified overloaded function, and TARGS should list template
-   arguments (e.g. <X>) when mtf or tf are to name a template
-   function, or be NULL otherwise.  Unqualified template-dependent
-   names can only resolve to overloaded functions, to be used in
-   contexts that make their argument types template-dependent, such as
-   call expressions with template-dependent arguments, conversion
+/* Build a template-dependent value expression (e.g., S::val or
+   S::template mtf<X>, or unqualified f or template tf<X>).
+
+   ENCLOSING_SCOPE should be a template-dependent nested name
+   specifier (e.g., T), a resolved namespace or class decl, or NULL
+   for unqualified names; ID should be the name of the member of the
+   ENCLOSING_SCOPE (e.g., val or mtf) or unqualified overloaded
+   function; and TARGS should list template arguments (e.g. <X>) when
+   mtf or tf are to name a template function, or be NULL otherwise.
+
+   Unqualified names and namespace- or class-qualified names can only
+   resolve to overloaded functions, to be used in contexts that
+   involve overload resolution that cannot be resolved because of
+   template-dependent argument or return types, such as call
+   expressions with template-dependent arguments, conversion
    expressions to function types with template-dependent argument
-   types or the like.
+   types or the like.  Other cases of unqualified or
+   non-template-dependent-qualified names should NOT use this
+   function, and use decl_expr to convert the appropriate function or
+   object declaration to an expression.
 
    If ID is the name of a special member function, FLAGS should be
    GCC_CP_SYMBOL_FUNCTION|GCC_CP_FLAG_SPECIAL_FUNCTION, and ID should
@@ -454,8 +461,8 @@ GCC_METHOD2 (gcc_type, new_dependent_typespec,
    target type of the conversion.  Otherwise, CONV_TYPE must be
    NULL.  */
 
-GCC_METHOD5 (gcc_decl, new_dependent_value_expr,
-	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+GCC_METHOD5 (gcc_expr, new_dependent_value_expr,
+	     gcc_decl,			 /* Argument ENCLOSING_SCOPE.  */
 	     enum gcc_cp_symbol_kind,		   /* Argument FLAGS.  */
 	     const char *,			    /* Argument NAME.  */
 	     gcc_type,			       /* Argument CONV_TYPE.  */
@@ -518,8 +525,7 @@ GCC_METHOD3 (gcc_expr, type_value_expr,
 
 /* Return the type of the gcc_expr OPERAND.
    Use this for decltype.
-
-   FIXME: introduce decltype (auto).
+   For decltype (auto), pass a NULL OPERAND.
 
    Note: for template-dependent expressions, the result is NULL,
    because the type is only computed when template argument
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index d51c04c..36fda16 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1823,16 +1823,16 @@ plugin_new_dependent_typespec (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (TREE_TYPE (decl)));
 }
 
-gcc_decl
+gcc_expr
 plugin_new_dependent_value_expr (cc1_plugin::connection *self,
-				 gcc_type enclosing_type,
+				 gcc_decl enclosing_scope,
 				 enum gcc_cp_symbol_kind flags,
 				 const char *name,
 				 gcc_type conv_type_in,
 				 const gcc_cp_template_args *targs)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
-  tree type = convert_in (enclosing_type);
+  tree scope = convert_in (enclosing_scope);
   tree conv_type = convert_in (conv_type_in);
   tree identifier;
 
@@ -2058,11 +2058,13 @@ plugin_new_dependent_value_expr (cc1_plugin::connection *self,
       gcc_assert (!conv_type);
       identifier = get_identifier (name);
     }
-  if (targs)
-    identifier = lookup_template_function (identifier, targlist (targs));
   tree res = identifier;
-  if (type)
-    res = build_qualified_name (NULL_TREE, type, identifier, !!targs);
+  if (!scope)
+    res = lookup_name_real (res, 0, 0, true, 0, 0);
+  if (targs)
+    res = lookup_template_function (res, targlist (targs));
+  if (scope)
+    res = build_qualified_name (NULL_TREE, scope, res, !!targs);
   return convert_out (ctx->preserve (res));
 }
 
@@ -2285,7 +2287,14 @@ plugin_expr_type (cc1_plugin::connection *,
 		  gcc_expr operand)
 {
   tree op0 = convert_in (operand);
-  tree type = TREE_TYPE (op0);
+  tree type;
+  if (op0)
+    type = TREE_TYPE (op0);
+  else
+    {
+      type = make_decltype_auto ();
+      AUTO_IS_DECLTYPE (type) = true;
+    }
   return convert_out (type);
 }
