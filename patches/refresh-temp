Bottom: 373462ad2cf38abb380391e69eea4c01e818b338
Top:    94f7360bf39acd1dc322e495f7d49bc02f64e57e
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-06-04 02:54:34 -0300

Refresh of remaining-unary-exprs.patch

---

diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index bba2fa7..af22bb3 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -868,7 +868,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 	      opcode = POSTINCREMENT_EXPR;
 	      break;
 	    case CHARS2 ('m', 'm'): // operator --
-	      opcode = POSTDECREMENT_EXPR;
+	      opcode = PREDECREMENT_EXPR;
 	      break;
 	    case CHARS2 ('c', 'm'): // operator ,
 	      opcode = COMPOUND_EXPR;
@@ -2319,7 +2319,9 @@ plugin_unary_value_expr (cc1_plugin::connection *self,
   plugin_context *ctx = static_cast<plugin_context *> (self);
   tree op0 = convert_in (operand);
   tree_code opcode = ERROR_MARK;
+  bool global_scope_p = false;
 
+ once_more:
   switch (CHARS2 (unary_op[0], unary_op[1]))
     {
     case CHARS2 ('p', 's'): // operator + (unary)
@@ -2340,29 +2342,114 @@ plugin_unary_value_expr (cc1_plugin::connection *self,
     case CHARS2 ('n', 't'): // operator !
       opcode = TRUTH_NOT_EXPR;
       break;
-      /* FIXME: __real__, __imag__,
-	 [global-scope] delete, delete[],
-	 preinc, predec, noexcept,
-	 non-type typeid, sizeof, alignof,
-	 sizeof...(pack), pack... (expansion), throw (rethrow?).  */
     case CHARS2 ('p', 'p'): // operator ++
+      opcode = unary_op[2] == '_' ? PREINCREMENT_EXPR : POSTINCREMENT_EXPR;
+      break;
     case CHARS2 ('m', 'm'): // operator --
+      opcode = unary_op[2] == '_' ? PREDECREMENT_EXPR : POSTDECREMENT_EXPR;
+      break;
+    case CHARS2 ('n', 'x'): // noexcept
+      opcode = NOEXCEPT_EXPR;
+      break;
+    case CHARS2 ('t', 'w'): // throw
+      gcc_assert (op0);
+      opcode = THROW_EXPR;
+      break;
+    case CHARS2 ('t', 'r'): // rethrow
+      gcc_assert (!op0);
+      opcode = THROW_EXPR;
+      break;
+    case CHARS2 ('t', 'e'): // typeid (value)
+      opcode = TYPEID_EXPR;
+      break;
+    case CHARS2 ('s', 'z'): // sizeof (value)
+      opcode = SIZEOF_EXPR;
+      break;
+    case CHARS2 ('a', 'z'): // alignof (value)
+      opcode = ALIGNOF_EXPR;
+      break;
+    case CHARS2 ('g', 's'): // global scope (for delete, delete[])
+      gcc_assert (!global_scope_p);
+      global_scope_p = true;
+      unary_op += 2;
+      goto once_more;
+    case CHARS2 ('d', 'l'): // delete
+      opcode = DELETE_EXPR;
+      break;
+    case CHARS2 ('d', 'a'): // delete[]
+      opcode = VEC_DELETE_EXPR;
+      break;
+    case CHARS2 ('s', 'p'): // pack...
+      opcode = EXPR_PACK_EXPANSION;
+      break;
+    case CHARS2 ('s', 'Z'): // sizeof...(pack)
+      opcode = TYPE_PACK_EXPANSION; // Not really, but let's use its code.
+      break;
+
+      /* FIXME: __real__, __imag__?  */
+
     default:
       gcc_unreachable ();
     }
 
+  gcc_assert (!global_scope_p
+	      || opcode == DELETE_EXPR || opcode == VEC_DELETE_EXPR);
+
   processing_template_decl++;
-  bool template_dependent_p = type_dependent_expression_p (op0)
-    || value_dependent_expression_p (op0);
+  bool template_dependent_p = op0
+    && (type_dependent_expression_p (op0)
+	|| value_dependent_expression_p (op0));
   if (!template_dependent_p)
     processing_template_decl--;
 
-  tree val = build_x_unary_op (/*loc=*/0, opcode, op0, tf_error);
+  tree result;
+
+  gcc_assert (op0 || opcode == THROW_EXPR);
+
+  switch (opcode)
+    {
+    case NOEXCEPT_EXPR:
+      result = finish_noexcept_expr (op0, tf_warning_or_error);
+      break;
+
+    case THROW_EXPR:
+      result = build_throw (op0);
+      break;
+
+    case TYPEID_EXPR:
+      result = build_typeid (op0, tf_warning_or_error);
+      break;
+
+    case SIZEOF_EXPR:
+    case ALIGNOF_EXPR:
+      result = cxx_sizeof_or_alignof_expr (op0, opcode, true);
+      break;
+
+    case DELETE_EXPR:
+    case VEC_DELETE_EXPR:
+      result = delete_sanity (op0, NULL_TREE, opcode == VEC_DELETE_EXPR,
+			      global_scope_p, tf_warning_or_error);
+      break;
+
+    case EXPR_PACK_EXPANSION:
+      result = make_pack_expansion (op0);
+      break;
+
+      // We're using this for sizeof...(pack).  */
+    case TYPE_PACK_EXPANSION:
+      result = make_pack_expansion (op0);
+      PACK_EXPANSION_SIZEOF_P (result) = true;
+      break;
+
+    default:
+      result = build_x_unary_op (/*loc=*/0, opcode, op0, tf_error);
+      break;
+    }
 
   if (template_dependent_p)
     processing_template_decl--;
 
-  return convert_out (ctx->preserve (val));
+  return convert_out (ctx->preserve (result));
 }
 
 gcc_expr
@@ -2508,7 +2595,25 @@ plugin_unary_type_expr (cc1_plugin::connection *self,
 
   switch (CHARS2 (unary_op[0], unary_op[1]))
     {
-      /* FIXME: implement typeid, sizeof, alignof, ...  */
+    case CHARS2 ('t', 'i'): // typeid (type)
+      opcode = TYPEID_EXPR;
+      break;
+
+    case CHARS2 ('s', 't'): // sizeof (type)
+      opcode = SIZEOF_EXPR;
+      break;
+    case CHARS2 ('a', 't'): // alignof (type)
+      opcode = ALIGNOF_EXPR;
+      break;
+
+    case CHARS2 ('s', 'Z'): // sizeof...(pack)
+      opcode = TYPE_PACK_EXPANSION; // Not really, but let's use its code.
+      break;
+
+      // FIXME: do we have to handle "sp", for the size of a captured
+      // template parameter pack from an alias template, taking
+      // multiple template arguments?
+
     default:
       gcc_unreachable ();
     }
@@ -2518,7 +2623,23 @@ plugin_unary_type_expr (cc1_plugin::connection *self,
   if (!template_dependent_p)
     processing_template_decl--;
 
-  tree val = cxx_sizeof_or_alignof_type (type, opcode, true);
+  tree result;
+
+  switch (opcode)
+    {
+    case TYPEID_EXPR:
+      result = get_typeid (type, tf_warning_or_error);
+      break;
+
+      // We're using this for sizeof...(pack).  */
+    case TYPE_PACK_EXPANSION:
+      result = make_pack_expansion (op0);
+      PACK_EXPANSION_SIZEOF_P (result) = true;
+      break;
+
+    default:
+      result = cxx_sizeof_or_alignof_type (type, opcode, true);
+    }
 
   if (template_dependent_p)
     processing_template_decl--;
