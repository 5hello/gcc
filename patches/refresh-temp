Bottom: 945b43a885c89f0585df7729a234a296171e3119
Top:    c2d275fa0d0f10e7a69d1537e55a195d119dd6db
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2015-12-29 00:39:42 -0200

Refresh of template-support.patch

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 77a20fe..69c4c83 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -228,18 +228,14 @@ GCC_METHOD5 (gcc_type, new_template_typename_parm,
 	     unsigned int)		     /* Argument LINE_NUMBER.  */
 
 /* Build a template template-parameter (e.g., the T in template
-   <template <[...]> class T = X>).  Either PACK_P should be nonzero,
-   to indicate an argument pack (the last argument in a variadic
-   template argument list, as in template <template <[...]>
-   typename... T>), or DEFAULT_TDECL may be non-NULL to set the
-   default type-template argument (e.g. X) for the template template
-   parameter.  FILENAME and LINE_NUMBER may specify the source
-   location in which the template parameter was declared.  */
+   <template <[...]> class T = X>).  DEFAULT_TEMPL may be non-NULL to
+   set the default type-template argument (e.g. X) for the template
+   template parameter.  FILENAME and LINE_NUMBER may specify the
+   source location in which the template parameter was declared.  */
 
-GCC_METHOD5 (gcc_decl, new_template_template_parm,
+GCC_METHOD4 (gcc_decl, new_template_template_parm,
 	     const char *,			      /* Argument ID.  */
-	     int /* bool */,			  /* Argument PACK_P.  */
-	     gcc_decl,			   /* Argument DEFAULT_TDECL.  */
+	     gcc_decl,			   /* Argument DEFAULT_TEMPL.  */
 	     const char *,			/* Argument FILENAME.  */
 	     unsigned int)		     /* Argument LINE_NUMBER.  */
 
@@ -283,7 +279,7 @@ GCC_METHOD2 (gcc_decl, new_dependent_class_template,
    (e.g., the T in template <template <[...]> class T = X>), and TARGS
    should specify the template arguments (e.g. <A>).  */
 
-GCC_METHOD3 (gcc_type, new_dependent_typespec,
+GCC_METHOD2 (gcc_type, new_dependent_typespec,
 	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
@@ -367,7 +363,7 @@ GCC_METHOD1 (gcc_type, expr_type,
    specialization.  FILENAME and LINE_NUMBER specify the source
    location associated with the template function specialization.  */
 
-GCC_METHOD4 (gcc_expr, specialize_function_template,
+GCC_METHOD5 (gcc_decl, specialize_function_template,
 	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
 	     gcc_address,			 /* Argument ADDRESS.  */
@@ -382,7 +378,7 @@ GCC_METHOD4 (gcc_expr, specialize_function_template,
    class NAME.  FILENAME and LINE_NUMBER specify the source location
    associated with the template class specialization.  */
 
-GCC_METHOD4 (gcc_type, start_new_class_type,
+GCC_METHOD5 (gcc_type, start_specialize_class_template,
 	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *,  /* Argument TARGS.  */
 	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
@@ -424,7 +420,7 @@ GCC_METHOD3 (gcc_type, start_new_union_type,
 
    FIXME: how about mutable data members?  */
 
-GCC_METHOD5 (int /* bool */, new_field,
+GCC_METHOD4 (int /* bool */, new_field,
 	     const char *,		   /* Argument FIELD_NAME.  */
 	     gcc_type,			   /* Argument FIELD_TYPE.  */
 	     unsigned long,		   /* Argument BITSIZE.  */
@@ -435,7 +431,7 @@ GCC_METHOD5 (int /* bool */, new_field,
    cleanups in GCC, and pops to the binding level that was in effect
    before the matching build_class_type or build_union_type.  */
 
-GCC_METHOD2 (int /* bool */, finish_record_or_union,
+GCC_METHOD1 (int /* bool */, finish_record_or_union,
 	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */
 
 /* Create a new 'enum' type, and record it in the current binding
@@ -454,14 +450,14 @@ GCC_METHOD5 (gcc_type, start_new_enum_type,
 /* Add a new constant to the most-recently-started enum type.  NAME is
    the constant's name and VALUE is its value.  */
 
-GCC_METHOD3 (int /* bool */, build_add_enum_constant,
+GCC_METHOD2 (int /* bool */, build_add_enum_constant,
 	     const char *,	       /* Argument NAME.  */
 	     unsigned long)	       /* Argument VALUE.  */
 
 /* After all the constants have been added to an enum, the type must
    be "finished".  This does some final cleanups in GCC.  */
 
-GCC_METHOD1 (int /* bool */, finish_enum_type)
+GCC_METHOD0 (int /* bool */, finish_enum_type)
 
 /* Create a new function type.  RETURN_TYPE is the type returned by
    the function, and ARGUMENT_TYPES is a vector, of length NARGS, of
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index bb24af1..37993b5 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -85,6 +85,14 @@ struct gcc_vbase_array
 
 typedef unsigned long long gcc_expr;
 
+typedef enum
+{ GCC_CP_TPARG_VALUE, GCC_CP_TPARG_CLASS, GCC_CP_TPARG_TEMPL }
+gcc_cp_template_arg_kind;
+
+typedef union
+{ gcc_expr value; gcc_type type; gcc_decl templ; }
+gcc_cp_template_arg;
+  
 /* An array of template arguments.  */
 
 struct gcc_cp_template_args
@@ -93,14 +101,13 @@ struct gcc_cp_template_args
 
   int n_elements;
 
-  /* Indicate whether an argument is a type.
-     elements[i] is a type iff typep[i].  */
+  /* kind[i] indicates what kind of template argument type[i] is.  */
 
-  char /* bool */ *typep;
+  char /* gcc_cp_template_arg_kind */ *kinds;
 
-  /* The base classes.  */
+  /* The template arguments.  */
 
-  union { gcc_expr value; gcc_type type; } *elements;
+  gcc_cp_template_arg *elements;
 };
 
 /* This enumerates the kinds of decls that GDB can create.  */
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index d6551a6..06e3ddb 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -976,13 +976,12 @@ plugin_start_new_union_type (cc1_plugin::connection *self,
 
 int
 plugin_new_field (cc1_plugin::connection *,
-		  gcc_type record_or_union_type_in,
 		  const char *field_name,
 		  gcc_type field_type_in,
 		  unsigned long bitsize,
 		  unsigned long bitpos)
 {
-  tree record_or_union_type = convert_in (record_or_union_type_in);
+  tree record_or_union_type = current_class_type;
   tree field_type = convert_in (field_type_in);
 
   gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (record_or_union_type)));
@@ -1022,10 +1021,9 @@ plugin_new_field (cc1_plugin::connection *,
 
 int
 plugin_finish_record_or_union (cc1_plugin::connection *,
-			       gcc_type record_or_union_type_in,
 			       unsigned long size_in_bytes)
 {
-  tree record_or_union_type = convert_in (record_or_union_type_in);
+  tree record_or_union_type = current_class_type;
 
   gcc_assert (RECORD_OR_UNION_CODE_P (TREE_CODE (record_or_union_type)));
 
@@ -1072,11 +1070,10 @@ plugin_start_new_enum_type (cc1_plugin::connection *self,
 
 int
 plugin_build_add_enum_constant (cc1_plugin::connection *,
-				gcc_type enum_type_in,
 				const char *name,
 				unsigned long value)
 {
-  tree enum_type = convert_in (enum_type_in);
+  tree enum_type = current_class_type;
 
   gcc_assert (TREE_CODE (enum_type) == ENUMERAL_TYPE);
 
@@ -1087,10 +1084,9 @@ plugin_build_add_enum_constant (cc1_plugin::connection *,
 }
 
 int
-plugin_finish_enum_type (cc1_plugin::connection *,
-			 gcc_type enum_type_in)
+plugin_finish_enum_type (cc1_plugin::connection *)
 {
-  tree enum_type = convert_in (enum_type_in);
+  tree enum_type = current_class_type;
 
   finish_enum_value_list (enum_type);
   finish_enum (enum_type);
@@ -1208,6 +1204,164 @@ plugin_build_pointer_to_member_type (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (memptr_type));
 }
 
+int
+plugin_start_new_template_decl (cc1_plugin::connection *self)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_new_template_typename_parm (cc1_plugin::connection *self,
+				   const char *id,
+				   int /* bool */ pack_p,
+				   gcc_type default_type,
+				   const char *filename,
+				   unsigned int line_number)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_decl
+plugin_new_template_template_parm (cc1_plugin::connection *self,
+				   const char *id,
+				   gcc_decl default_templ,
+				   const char *filename,
+				   unsigned int line_number)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_decl
+plugin_new_template_value_parm (cc1_plugin::connection *self,
+				gcc_type type,
+				const char *id,
+				gcc_expr default_value,
+				const char *filename,
+				unsigned int line_number)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_new_dependent_typename (cc1_plugin::connection *self,
+			       gcc_type enclosing_type,
+			       const char *id,
+			       const gcc_cp_template_args *targs)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_new_dependent_class_template (cc1_plugin::connection *self,
+				     gcc_type enclosing_type,
+				     const char *id)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_new_dependent_typespec (cc1_plugin::connection *self,
+			       gcc_decl template_decl,
+			       const gcc_cp_template_args *targs)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_new_dependent_value_expr (cc1_plugin::connection *self,
+				 gcc_type enclosing_type,
+				 const char *id,
+				 const gcc_cp_template_args *targs)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_literal_expr (cc1_plugin::connection *self,
+		     gcc_type type, unsigned long value)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_decl_expr (cc1_plugin::connection *self, gcc_decl decl)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_unary_value_expr (cc1_plugin::connection *self,
+			 const char *unary_op,
+			 gcc_expr operand)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_binary_value_expr (cc1_plugin::connection *self,
+			  const char *binary_op,
+			  gcc_expr operand1,
+			  gcc_expr operand2)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_ternary_value_expr (cc1_plugin::connection *self,
+			   const char *binary_op,
+			   gcc_expr operand1,
+			   gcc_expr operand2,
+			   gcc_expr operand3)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_unary_type_expr (cc1_plugin::connection *self,
+			const char *unary_op,
+			gcc_type operand)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_expr
+plugin_type_value_expr (cc1_plugin::connection *self,
+			const char *binary_op,
+			gcc_type operand1,
+			gcc_expr operand2)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_expr_type (cc1_plugin::connection *self,
+		  gcc_expr operand)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_decl
+plugin_specialize_function_template (cc1_plugin::connection *self,
+				     gcc_decl template_decl,
+				     const gcc_cp_template_args *targs,
+				     gcc_address address,
+				     const char *filename,
+				     unsigned int line_number)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
+plugin_start_specialize_class_template (cc1_plugin::connection *self,
+					gcc_decl template_decl,
+					const gcc_cp_template_args *args,
+					const gcc_vbase_array *base_classes,
+					const char *filename,
+					unsigned int line_number)
+{
+  /* FIXME: implement.  */
+}
+
 gcc_type
 plugin_int_type (cc1_plugin::connection *self,
 		 int is_unsigned, unsigned long size_in_bytes)
@@ -1266,6 +1420,14 @@ plugin_build_array_type (cc1_plugin::connection *self,
 }
 
 gcc_type
+plugin_build_dependent_array_type (cc1_plugin::connection *self,
+				   gcc_type element_type_in,
+				   gcc_expr num_elements_in)
+{
+  /* FIXME: implement.  */
+}
+
+gcc_type
 plugin_build_vla_array_type (cc1_plugin::connection *self,
 			     gcc_type element_type_in,
 			     const char *upper_bound_name)
@@ -1319,9 +1481,10 @@ plugin_build_vector_type (cc1_plugin::connection *self,
 }
 
 int
-plugin_build_constant (cc1_plugin::connection *self, gcc_type type_in,
-		       const char *name, unsigned long value,
-		       const char *filename, unsigned int line_number)
+plugin_build_constant_deprecated (cc1_plugin::connection *self,
+				  gcc_type type_in,
+				  const char *name, unsigned long value,
+				  const char *filename, unsigned int line_number)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   tree cst, decl;
diff --git a/libcc1/marshall-cp.hh b/libcc1/marshall-cp.hh
index 5f6fc65..8ce13ee 100644
--- a/libcc1/marshall-cp.hh
+++ b/libcc1/marshall-cp.hh
@@ -136,6 +136,78 @@ namespace cc1_plugin
     *result = gva;
     return OK;
   }
+
+  // Send a gcc_cp_template_args marker followed by the array.
+  status
+  marshall (connection *conn, const gcc_cp_template_args *a)
+  {
+    size_t len;
+
+    if (a)
+      len = a->n_elements;
+    else
+      len = (size_t)-1;
+
+    if (!marshall_array_start (conn, 't', len))
+      return FAIL;
+
+    if (!a)
+      return OK;
+
+    if (!marshall_array_elmts (conn, len * sizeof (a->kinds[0]),
+			       a->kinds))
+      return FAIL;
+
+    return marshall_array_elmts (conn, len * sizeof (a->elements[0]),
+				 a->elements);
+  }
+
+  // Read a gcc_vbase_array marker, followed by a gcc_vbase_array.  The
+  // resulting array must be freed by the caller, using 'delete[]' on
+  // elements and virtualp, and 'delete' on the array object itself.
+  status
+  unmarshall (connection *conn, struct gcc_cp_template_args **result)
+  {
+    size_t len;
+
+    if (!unmarshall_array_start (conn, 't', &len))
+      return FAIL;
+
+    if (len == (size_t)-1)
+      {
+	*result = NULL;
+	return OK;
+      }
+
+    struct gcc_cp_template_args *gva = new gcc_cp_template_args;
+
+    gva->n_elements = len;
+    gva->kinds = new char[len];
+
+    if (!unmarshall_array_elmts (conn,
+				 len * sizeof (gva->kinds[0]),
+				 gva->kinds))
+      {
+	delete[] gva->kinds;
+	delete gva;
+	return FAIL;
+      }
+
+    gva->elements = new gcc_cp_template_arg[len];
+
+    if (!unmarshall_array_elmts (conn,
+				 len * sizeof (gva->elements[0]),
+				 gva->elements))
+      {
+	delete[] gva->elements;
+	delete[] gva->kinds;
+	delete gva;
+	return FAIL;
+      }
+
+    *result = gva;
+    return OK;
+  }
 }
 
 #endif // CC1_PLUGIN_MARSHALL_CP_HH
diff --git a/libcc1/rpc.hh b/libcc1/rpc.hh
index be81c49..f9efe04 100644
--- a/libcc1/rpc.hh
+++ b/libcc1/rpc.hh
@@ -126,7 +126,7 @@ namespace cc1_plugin
   };
 
 #ifdef GCC_CP_INTERFACE_H
-  // Specialization for gcc_type_array.
+  // Specialization for gcc_vbase_array.
   template<>
   class argument_wrapper<const gcc_vbase_array *>
   {
@@ -162,6 +162,43 @@ namespace cc1_plugin
     argument_wrapper (const argument_wrapper &);
     argument_wrapper &operator= (const argument_wrapper &);
   };
+
+  // Specialization for gcc_cp_template_args.
+  template<>
+  class argument_wrapper<const gcc_cp_template_args *>
+  {
+  public:
+    argument_wrapper () : m_object (NULL) { }
+    ~argument_wrapper ()
+    {
+      // It would be nicer if gcc_type_array could have a destructor.
+      // But, it is in code shared with gdb and cannot.
+      if (m_object != NULL)
+	{
+	  delete[] m_object->elements;
+	  delete[] m_object->kinds;
+	}
+      delete m_object;
+    }
+
+    operator const gcc_cp_template_args * () const
+    {
+      return m_object;
+    }
+
+    status unmarshall (connection *conn)
+    {
+      return ::cc1_plugin::unmarshall (conn, &m_object);
+    }
+
+  private:
+
+    gcc_cp_template_args *m_object;
+
+    // No copying or assignment allowed.
+    argument_wrapper (const argument_wrapper &);
+    argument_wrapper &operator= (const argument_wrapper &);
+  };
 #endif /* GCC_CP_INTERFACE_H */
 
   // There are two kinds of template functions here: "call" and
