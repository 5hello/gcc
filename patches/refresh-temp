Bottom: b346058b9caf4e13c50a37fe0429903073983a5f
Top:    4e942fb245aab600f7bdbb15aed09df5bf5b1819
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-06-29 01:29:27 -0300

Refresh of split-class-decl-manage-scopes-reactivate-local-decls.patch

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 9518245..7fcd484 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -72,11 +72,22 @@ GCC_METHOD1 (int /* bool */, push_function,
    may contain multiple scopes (blocks), and the name may be bound to
    different symbols in each of these scopes.  With this interface, as
    we reenter a function scope, we may choose which symbols to make
-   visible for other declarations nested in that function scope (e.g.,
-   for unresolved names in nested template class default arguments, or
-   in nested template function signatures), or while compiling the
-   code snippet (see FIXME: figure out how to get into the right
-   context).
+   visible for the code snippet, or, if there could be template
+   functions in local scopes, for unresolved names in nested template
+   class default arguments, or in nested template function signatures.
+
+   As for making a local declaration visible for the code snippet,
+   there are two possibilities: a) introduce it upfront, while
+   entering the scope for the user expression (see the enter_scope
+   callback, called by g++ when encountering the push_user_expression
+   pragma), which might save some scope switching and reactivate_decl
+   (though this can't be helped if some declarations have to be
+   introduced and discarded, because of multiple definitions of the
+   same name in different scopes within a function: they have to be
+   defined in discriminator order); or b) introduce it when its name
+   is looked up, entering the scope, introducing the declaration,
+   leaving the scope, and then reactivating the declaration in its
+   local scope.
 
    Here's some more detail on how reactivate_decl works.  Say there's
    a function foo whose body looks like this:
@@ -118,19 +129,30 @@ GCC_METHOD1 (int /* bool */, push_function,
    So, we declare c, then we leave the function scope and reenter it
    so as to declare c_0 (also with name "c", which is why we have to
    leave and reenter the function scope, otherwise we would get an
-   error becaus eof the duplicate definition; g++ will assign a
+   error because of the duplicate definition; g++ will assign a
    discriminator because it still remembers there was an earlier
    declaration of c_0 within the function, it's just no longer in
    scope), then we can define c_0, including its member function f.
 
    Likewise, if we wish to define o_0, we have to define o first.  If
    we wish to declare (and maybe then define) c_1, we have to at least
-   declare (c and) c_0 first.
+   declare (c and then) c_0 first.
 
    Then, as we set up the binding context to compile a code snippet at
-   point 3, we have to activate c_1, o_0 and p.  If the code snippet
-   is at point 2, we don't need to (re)activate anything: just
-   entering the scope of the class containing member function f
+   point 3, we may choose to activate c_1, o_0 and p upfront,
+   declaring and discarding c, c_0 and o, and then reentering the
+   funciton scope to declare c_1, o_0 and p; or we can wait for oracle
+   lookups of c, o or p.  If c is looked up, and the debugger resolves
+   c in the scope to c_1, it is expected to enter the function scope
+   from the top level, declare c, leave it, reenter it, declare c_0,
+   leave it, reenter it, declare c_1, leave it, and then reactivate
+   c_1 in the function scope.  If c_1 is needed as a complete type,
+   the definition may be given right after the declaration, or the
+   scope will have to be reentered in order to define the class.
+
+.  If the code snippet is at point 2, we don't need to (re)activate
+   anything declaration: nothing from any local scope is visible.
+   Just entering the scope of the class containing member function f
    reactivates the names of its members, including the class name
    itself.  */
 
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 69f6817..530ee29 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -450,7 +450,7 @@ reactivate_decl (tree decl, cp_binding_level *b)
   gcc_assert (in_function_p
 	      || (b == current_binding_level
 		  && !at_class_scope_p ()));
-      
+
   tree id = DECL_NAME (decl);
   tree type = NULL_TREE;
   if (TREE_CODE (decl) == TYPE_DECL)
