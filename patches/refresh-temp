Bottom: dc7515afd3bafeb8189262f26559c562c443a6ae
Top:    5bc39e9df0d9e1cd56b012f47e402f0339eee620
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-21 05:02:56 -0300

Refresh of lambda-closures.patch

---

diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index de467a3..8918f43 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-13
+  GCC_CP_FE_VERSION_0 = 0xffffffff-14
 };
 
 /* Qualifiers.  */
@@ -295,6 +295,22 @@ enum gcc_cp_symbol_kind
      may affect error messages.  */
   GCC_CP_FLAG_CLASS_IS_STRUCT = GCC_CP_FLAG_BASE,
 
+  /* This indicates the class is a lambda closure type.  In most
+     regards this is just like a regular class, but it's not supposed
+     to have base classes, some of the member functions that are
+     usually implicitly-defined are deleted, and it should have an
+     operator() member function that holds the lambda body.  We can't
+     instantiate objects of lambda types from the snippet, but we can
+     interact with them in such ways as passing them to functions that
+     take their types, and calling their body.  The name of a closure
+     type doesn't matter, since its operator() and any functions we
+     might want to call that take it as an argument are defined with
+     an address that avoids the need for using the mangled names to
+     begin with.  For now, it is probably safest to define closure
+     types in anonymous namespaces, so that their names don't
+     interfere with other symbols.  */
+  GCC_CP_FLAG_CLASS_IS_LAMBDA_CLOSURE = GCC_CP_FLAG_BASE << 1,
+
   GCC_CP_FLAG_END_CLASS,
   GCC_CP_FLAG_MASK_CLASS = (((GCC_CP_FLAG_END_CLASS - 1) << 1)
 			       - GCC_CP_FLAG_BASE),
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 1486948..3413af2 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1277,6 +1277,12 @@ plugin_start_new_class_type (cc1_plugin::connection *self,
   tree type = build_named_class_type (RECORD_TYPE, name, base_classes,
 				      ctx->get_source_location (filename,
 								line_number));
+  if ((flags & GCC_CP_CLASS_IS_LAMBDA_CLOSURE))
+    {
+      gcc_assert (!name);
+      gcc_assert (!base_classes);
+      CLASSTYPE_LAMBDA_EXPR (type) = error_mark_node;
+    }
   tree decl = TYPE_NAME (type);
 
   set_access_flags (decl, flags);
