Bottom: 328aa60e362e607ccf1653397f6b91fa58898607
Top:    52a430ec9dfe8d7355cd6a48c90f29656cc5bdb8
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-03-08 05:16:36 -0300

Refresh of template-support.patch

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index bbd6b8f..dcbcd61 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -214,6 +214,13 @@ GCC_METHOD2 (gcc_type, build_pointer_to_member_type,
 
 GCC_METHOD0 (int, start_new_template_decl)
 
+/* Return the declaration associated with the named type.  It is the
+   declaration, rather than the type proper, that has to be passed as
+   a template parameter.  */
+
+GCC_METHOD1 (gcc_typedecl, type_decl,
+	     gcc_type)            /* Argument TYPE.  */
+
 /* Build a typename template-parameter (e.g., the T in template
    <typename T = X>).  Either PACK_P should be nonzero, to indicate an
    argument pack (the last argument in a variadic template argument
@@ -222,10 +229,10 @@ GCC_METHOD0 (int, start_new_template_decl)
    parameter.  FILENAME and LINE_NUMBER may specify the source
    location in which the template parameter was declared.  */
 
-GCC_METHOD5 (gcc_type, new_template_typename_parm,
+GCC_METHOD5 (gcc_typedecl, new_template_typename_parm,
 	     const char *,			      /* Argument ID.  */
 	     int /* bool */,			  /* Argument PACK_P.  */
-	     gcc_type,			    /* Argument DEFAULT_TYPE.  */
+	     gcc_typedecl,		    /* Argument DEFAULT_TYPE.  */
 	     const char *,			/* Argument FILENAME.  */
 	     unsigned int)		     /* Argument LINE_NUMBER.  */
 
@@ -235,10 +242,10 @@ GCC_METHOD5 (gcc_type, new_template_typename_parm,
    template parameter.  FILENAME and LINE_NUMBER may specify the
    source location in which the template parameter was declared.  */
 
-GCC_METHOD5 (gcc_decl, new_template_template_parm,
+GCC_METHOD5 (gcc_utempl, new_template_template_parm,
 	     const char *,			      /* Argument ID.  */
 	     int /* bool */,			  /* Argument PACK_P.  */
-	     gcc_decl,			   /* Argument DEFAULT_TEMPL.  */
+	     gcc_utempl,		   /* Argument DEFAULT_TEMPL.  */
 	     const char *,			/* Argument FILENAME.  */
 	     unsigned int)		     /* Argument LINE_NUMBER.  */
 
@@ -249,32 +256,38 @@ GCC_METHOD5 (gcc_decl, new_template_template_parm,
    which the template parameter was declared.  */
 
 GCC_METHOD5 (gcc_decl, new_template_value_parm,
-	     gcc_type,			  	    /* Argument TYPE.  */
+	     gcc_typedecl,		  	    /* Argument TYPE.  */
 	     const char *,			      /* Argument ID.  */
 	     gcc_expr,			   /* Argument DEFAULT_VALUE.  */
 	     const char *,			/* Argument FILENAME.  */
 	     unsigned int)		     /* Argument LINE_NUMBER.  */
 
 /* Build a template-dependent typename (e.g., typename T::bar or
-   typename T::template bart<X> or T<X>).  ENCLOSING_TYPE should be
-   the nested name specifier (e.g., T), ID should be the name of the
-   member of the ENCLOSING_TYPE (e.g., bar or bart, or NULL), and
-   TARGS should be non-NULL and specify the template arguments
-   (e.g. <X>) iff ID is a template class or ID is NULL and
-   ENCLOSING_TYPE is a class template.  */
-
-GCC_METHOD3 (gcc_type, new_dependent_typename,
-	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+   typename T::template bart<X>).  ENCLOSING_TYPE should be the
+   template-dependent nested name specifier (e.g., T), ID should be
+   the name of the member of the ENCLOSING_TYPE (e.g., bar or bart),
+   and TARGS should be non-NULL and specify the template arguments
+   (e.g. <X>) iff ID is to name a class template.
+
+   In this and other calls, a template-dependent nested name specifier
+   may be a template class parameter (new_template_typename_parm), a
+   specialization (returned by new_dependent_typespec) of a template
+   template parameter (returned by new_template_template_parm) or a
+   member type thereof (returned by new_dependent_typename
+   itself).  */
+
+GCC_METHOD3 (gcc_typedecl, new_dependent_typename,
+	     gcc_typedecl,		  /* Argument ENCLOSING_TYPE.  */
 	     const char *,			      /* Argument ID.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
-/* Build a template-dependent class template (e.g., typename
-   T::template bar).  ENCLOSING_TYPE should be the nested name
+/* Build a template-dependent class template (e.g., T::template bart).
+   ENCLOSING_TYPE should be the template-dependent nested name
    specifier (e.g., T), ID should be the name of the class template
-   member of the ENCLOSING_TYPE (e.g., bar).  */
+   member of the ENCLOSING_TYPE (e.g., bart).  */
 
-GCC_METHOD2 (gcc_decl, new_dependent_class_template,
-	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+GCC_METHOD2 (gcc_utempl, new_dependent_class_template,
+	     gcc_typedecl,		  /* Argument ENCLOSING_TYPE.  */
 	     const char *)			      /* Argument ID.  */
 
 /* Build a template-dependent template type specialization (e.g.,
@@ -282,19 +295,19 @@ GCC_METHOD2 (gcc_decl, new_dependent_class_template,
    (e.g., the T in template <template <[...]> class T = X>), and TARGS
    should specify the template arguments (e.g. <A>).  */
 
-GCC_METHOD2 (gcc_type, new_dependent_typespec,
-	     gcc_decl,			   /* Argument TEMPLATE_DECL.  */
+GCC_METHOD2 (gcc_typedecl, new_dependent_typespec,
+	     gcc_utempl,		   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
 /* Build a template-dependent value expression (e.g., T::val or
-   T::template f<X>).  ENCLOSING_TYPE should be the nested name
-   specifier (e.g., T), ID should be the name of the member of the
-   ENCLOSING_TYPE (e.g., val or f), and TARGS should list template
-   arguments (e.g. <X>) when f is explicitly qualified as a template,
-   or be NULL otherwise.  */
-
-GCC_METHOD3 (gcc_expr, new_dependent_value_expr,
-	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
+   T::template f<X>).  ENCLOSING_TYPE should be the template-dependent
+   nested name specifier (e.g., T), ID should be the name of the
+   member of the ENCLOSING_TYPE (e.g., val or f), and TARGS should
+   list template arguments (e.g. <X>) when f is to name a template
+   function, or be NULL otherwise.  */
+
+GCC_METHOD3 (gcc_decl, new_dependent_value_expr,
+	     gcc_typedecl,		  /* Argument ENCLOSING_TYPE.  */
 	     const char *,			      /* Argument ID.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
@@ -353,10 +366,10 @@ GCC_METHOD3 (gcc_expr, type_value_expr,
 
 /* FIXME: function call operations?  ctor/dtor?  new/delete?  */
 
-/* Return the gcc_type of the gcc_expr OPERAND.
+/* Return the type of the gcc_expr OPERAND.
    Use this for decltype.  */
 
-GCC_METHOD1 (gcc_type, expr_type,
+GCC_METHOD1 (gcc_typedecl, expr_type,
 	     gcc_expr)		  /* Argument OPERAND.  */
 
 /* Introduce a specialization of a template function.
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index b5d3095..b002b07 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -79,20 +79,33 @@ struct gcc_vbase_array
   char /* bool */ *virtualp;
 };
 
+/* Opaque typedef for type declarations.  They are used for template
+   arguments, defaults for type template parameters, and types used to
+   build type-conversion expressions.  */
+
+typedef unsigned long long gcc_typedecl;
+
+/* Opaque typedef for unbound class templates.  They are used for
+   template arguments, and defaults for template template
+   parameters.  */
+
+typedef unsigned long long gcc_utempl;
+
 /* Opaque typedef for expressions.  They are used for template
-   arguments, default values for non-type template parameters, and
-   default arguments for functions.  */
+   arguments, defaults for non-type template parameters, and defaults
+   for function arguments.  */
 
 typedef unsigned long long gcc_expr;
 
 /* FIXME: do we need to support argument packs?  */
 
 typedef enum
-{ GCC_CP_TPARG_VALUE, GCC_CP_TPARG_CLASS, GCC_CP_TPARG_TEMPL }
+  { GCC_CP_TPARG_VALUE, GCC_CP_TPARG_CLASS,
+    GCC_CP_TPARG_TEMPL, GCC_CP_TPARG_PACK }
 gcc_cp_template_arg_kind;
 
 typedef union
-{ gcc_expr value; gcc_type type; gcc_decl templ; }
+{ gcc_expr value; gcc_typedecl type; gcc_utempl templ; gcc_typedecl pack; }
 gcc_cp_template_arg;
 
 /* An array of template arguments.  */
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 8eea7f6..a61ea33 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1266,11 +1266,24 @@ plugin_start_new_template_decl (cc1_plugin::connection *self ATTRIBUTE_UNUSED)
   return 0;
 }
 
-gcc_type
+gcc_typedecl
+plugin_type_decl (cc1_plugin::connection *self,
+		  gcc_type type_in)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree type = convert_in (type_in);
+
+  tree name = TYPE_NAME (type);
+  gcc_assert (name);
+
+  return convert_out (name);
+}
+
+gcc_typedecl
 plugin_new_template_typename_parm (cc1_plugin::connection *self,
 				   const char *id,
 				   int /* bool */ pack_p,
-				   gcc_type default_type,
+				   gcc_typedecl default_type,
 				   const char *filename,
 				   unsigned int line_number)
 {
@@ -1291,11 +1304,11 @@ plugin_new_template_typename_parm (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (TREE_TYPE (tree_last (TP_PARM_LIST))));
 }
 
-gcc_decl
+gcc_utempl
 plugin_new_template_template_parm (cc1_plugin::connection *self,
 				   const char *id,
 				   int /* bool */ pack_p,
-				   gcc_decl default_templ,
+				   gcc_utempl default_templ,
 				   const char *filename,
 				   unsigned int line_number)
 {
@@ -1358,41 +1371,89 @@ plugin_new_template_value_parm (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (tree_last (TP_PARM_LIST)));
 }
 
-gcc_type
+static tree
+targlist (const gcc_cp_template_args *targs)
+{
+  int n = targs->n_elements;
+  tree vec = make_tree_vec (n);
+  while (n--)
+    {
+      switch (targs->kinds[n])
+	{
+	case GCC_CP_TPARG_VALUE:
+	  TREE_VEC_ELT (vec, n) = convert_in (targs->elements[n].value);
+	  break;
+	case GCC_CP_TPARG_CLASS:
+	  TREE_VEC_ELT (vec, n) = convert_in (targs->elements[n].type);
+	  break;
+	case GCC_CP_TPARG_TEMPL:
+	  TREE_VEC_ELT (vec, n) = convert_in (targs->elements[n].templ);
+	  break;
+	case GCC_CP_TPARG_PACK:
+	  TREE_VEC_ELT (vec, n) = convert_in (targs->elements[n].pack);
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+    }
+  return vec;
+}
+
+gcc_typedecl
 plugin_new_dependent_typename (cc1_plugin::connection *self,
-			       gcc_type enclosing_type,
+			       gcc_typedecl enclosing_type,
 			       const char *id,
 			       const gcc_cp_template_args *targs)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   tree type = convert_in (enclosing_type);
-  
-  /* FIXME: implement.  */
+  tree name = get_identifier (id);
+  if (targs)
+    name = build_min_nt_loc (/*loc=*/0, TEMPLATE_ID_EXPR,
+			     name, targlist (targs));
+  tree res = make_typename_type (type, name, typename_type,
+				 /*complain=*/tf_error);
+  return convert_out (ctx->preserve (res));
 }
 
-gcc_type
+gcc_utempl
 plugin_new_dependent_class_template (cc1_plugin::connection *self,
-				     gcc_type enclosing_type,
+				     gcc_typedecl enclosing_type,
 				     const char *id)
 {
-  /* FIXME: implement.  */
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree type = convert_in (enclosing_type);
+  tree name = get_identifier (id);
+  tree res = make_unbound_class_template (type, name, NULL_TREE,
+					  /*complain=*/tf_error);
+  return convert_out (ctx->preserve (res));
 }
 
-gcc_type
+gcc_typedecl
 plugin_new_dependent_typespec (cc1_plugin::connection *self,
-			       gcc_decl template_decl,
+			       gcc_utempl template_decl,
 			       const gcc_cp_template_args *targs)
 {
-  /* FIXME: implement.  */
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree type = convert_in (template_decl);
+  tree decl = finish_template_type (type, targlist (targs),
+				    /*entering_scope=*/false);
+  return convert_out (ctx->preserve (decl));
 }
 
-gcc_expr
+gcc_decl
 plugin_new_dependent_value_expr (cc1_plugin::connection *self,
-				 gcc_type enclosing_type,
+				 gcc_typedecl enclosing_type,
 				 const char *id,
 				 const gcc_cp_template_args *targs)
 {
-  /* FIXME: implement.  */
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree type = convert_in (enclosing_type);
+  tree name = get_identifier (id);
+  if (targs)
+    name = lookup_template_function (name, targlist (targs));
+  tree res = build_qualified_name (NULL_TREE, type, name, !!targs);
+  return convert_out (ctx->preserve (res));
 }
 
 gcc_expr
@@ -1452,7 +1513,7 @@ plugin_type_value_expr (cc1_plugin::connection *self,
   /* FIXME: implement.  */
 }
 
-gcc_type
+gcc_typedecl
 plugin_expr_type (cc1_plugin::connection *self,
 		  gcc_expr operand)
 {
