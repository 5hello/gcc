Bottom: 970be8a2e7e89a6b72f4f62dfafadee914026bfa
Top:    2c79b93f0d34235a258c62bb42ee9a34006ddbd0
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-04-09 06:02:23 -0300

Refresh of fwdeclare-classes-and-templates.patch

---

diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index c17745a..796e34a 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -569,22 +569,41 @@ plugin_new_decl (cc1_plugin::connection *self,
 	    case CHARS2 ('C', '1'): // in-charge constructor
 	      identifier = complete_ctor_identifier;
 	      ctor = true;
+	      gcc_assert (!template_decl_p);
 	      break;
 	    case CHARS2 ('C', '2'): // not-in-charge constructor
 	      identifier = base_ctor_identifier;
 	      ctor = true;
+	      gcc_assert (!template_decl_p);
+	      break;
+	    case CHARS2 ('C', '4'):
+	      identifier = ctor_identifier; // unified constructor
+	      ctor = true;
+	      /* This one can be a template, but we have no means for
+		 GDB to actively inform us the addresses of clones of
+		 a specialization.  That's kind of all right: we can
+		 get the addresses through the address oracle should
+		 we need them.  */
 	      break;
 	    case CHARS2 ('D', '0'): // deleting destructor
 	      identifier = deleting_dtor_identifier;
 	      dtor = true;
+	      gcc_assert (!template_decl_p);
 	      break;
 	    case CHARS2 ('D', '1'): // in-charge destructor
 	      identifier = complete_dtor_identifier;
 	      dtor = true;
+	      gcc_assert (!template_decl_p);
 	      break;
 	    case CHARS2 ('D', '2'): // not-in-charge destructor
 	      identifier = base_dtor_identifier;
 	      dtor = true;
+	      gcc_assert (!template_decl_p);
+	      break;
+	    case CHARS2 ('D', '4'):
+	      identifier = dtor_identifier; // unified destructor
+	      dtor = true;
+	      gcc_assert (!template_decl_p);
 	      break;
 	    case CHARS2 ('n', 'w'): // operator new
 	      opcode = NEW_EXPR;
@@ -832,64 +851,10 @@ plugin_new_decl (cc1_plugin::connection *self,
 	}
       if (ctor || dtor)
 	{
-	  tree fns = NULL_TREE;
 	  if (ctor)
-	    {
-	      DECL_CONSTRUCTOR_P (decl) = 1;
-	      fns = CLASSTYPE_CONSTRUCTORS (current_class_type);
-	    }
+	    DECL_CONSTRUCTOR_P (decl) = 1;
 	  if (dtor)
-	    {
-	      DECL_DESTRUCTOR_P (decl) = 1;
-	      fns = CLASSTYPE_DESTRUCTORS (current_class_type);
-	    }
-	  DECL_CONTEXT (decl) = FROB_CONTEXT (current_class_type);
-	  set_access_flags (decl, acc_flags);
-	  maybe_retrofit_in_chrg (decl);
-	  for (; fns; fns = OVL_NEXT (fns))
-	    {
-	      tree fn = OVL_CURRENT (fns);
-	      /* FIXME: handle template ctors.  */
-	      if (TREE_TYPE (decl) == TREE_TYPE (fn))
-		{
-		  decl = fn;
-		  break;
-		}
-	    }
-	  if (!fns)
-	    {
-	      /* FIXME: handle template ctors.  */
-	      finish_member_declaration (decl);
-	      /* ctors and dtors clones are chained after DECL.
-		 However, we create the clones before TYPE_METHODS is
-		 reversed.  We test for cloned methods after reversal,
-		 however, and the test requires the clones to follow
-		 DECL.  So, we reverse the chain of clones now, so
-		 that it will come out in the right order after
-		 reversal.  */
-	      tree save = DECL_CHAIN (decl);
-	      DECL_CHAIN (decl) = NULL_TREE;
-	      clone_function_decl (decl, /*update_method_vec_p=*/1);
-	      gcc_assert (TYPE_METHODS (current_class_type) == decl);
-	      TYPE_METHODS (current_class_type)
-		= nreverse (TYPE_METHODS (current_class_type));
-	      DECL_CHAIN (decl) = save;
-	    }
-	  /* Reverse the method chain temporarily, so that we can find
-	     the clones after DECL.  The clones are supposed to be
-	     introduced one right after the other, so truncating the
-	     list at DECL for the temporary reversal will yield a very
-	     short list.  */
-	  tree save = DECL_CHAIN (decl), abstract_decl = decl;
-	  DECL_CHAIN (decl) = NULL_TREE;
-	  TYPE_METHODS (current_class_type)
-	    = nreverse (TYPE_METHODS (current_class_type));
-	  for (decl = DECL_CHAIN (decl); decl; decl = DECL_CHAIN (decl))
-	    if (DECL_NAME (decl) == identifier)
-	      break;
-	  TYPE_METHODS (current_class_type)
-	    = nreverse (TYPE_METHODS (current_class_type));
-	  DECL_CHAIN (abstract_decl) = save;
+	    DECL_DESTRUCTOR_P (decl) = 1;
 	}
       else
 	{
@@ -954,7 +919,9 @@ plugin_new_decl (cc1_plugin::connection *self,
 
   set_access_flags (decl, acc_flags);
 
-  if (sym_kind != GCC_CP_SYMBOL_TYPEDEF)
+  if (sym_kind != GCC_CP_SYMBOL_TYPEDEF
+      && sym_kind != GCC_CP_SYMBOL_CLASS
+      && !template_decl_p)
     {
       decl_addr_value value;
 
@@ -978,11 +945,37 @@ plugin_new_decl (cc1_plugin::connection *self,
 	record_decl_address (ctx, value);
     }
 
+  tree fns = NULL_TREE;
+
   if (class_member_p && code == FUNCTION_DECL)
-    grok_special_member_properties (decl);
+    {
+      if (ctor || dtor)
+	{
+	  maybe_retrofit_in_chrg (decl);
+	  if (ctor)
+	    fns = CLASSTYPE_CONSTRUCTORS (current_class_type);
+	  if (dtor)
+	    fns = CLASSTYPE_DESTRUCTORS (current_class_type);
+	  for (; fns; fns = OVL_NEXT (fns))
+	    {
+	      tree fn = OVL_CURRENT (fns);
+	      if (TREE_TYPE (decl) == TREE_TYPE (fn))
+		{
+		  decl = fn;
+		  break;
+		}
+	    }
+	}
+
+      grok_special_member_properties (decl);
+    }
 
   if (template_decl_p)
     {
+      /* Since we only accept template declarations of the unified
+	 ctor, we don't have to special-case ctors here.  */
+      gcc_assert (!ctor || !fns);
+
       decl = safe_push_template_decl (decl);
       
       end_template_decl ();
@@ -998,12 +991,49 @@ plugin_new_decl (cc1_plugin::connection *self,
     }
   else if (class_member_p)
     {
-      if (!(ctor || dtor))
+      if (!(ctor || dtor) || !fns)
 	finish_member_declaration (decl);
     }
   else
     decl = safe_pushdecl_maybe_friend (decl, false);
 
+  if (ctor || dtor)
+    {
+      if (!fns)
+	{
+	  /* ctors and dtors clones are chained after DECL.
+	     However, we create the clones before TYPE_METHODS is
+	     reversed.  We test for cloned methods after reversal,
+	     however, and the test requires the clones to follow
+	     DECL.  So, we reverse the chain of clones now, so
+	     that it will come out in the right order after
+	     reversal.  */
+	  tree save = DECL_CHAIN (decl);
+	  DECL_CHAIN (decl) = NULL_TREE;
+	  clone_function_decl (decl, /*update_method_vec_p=*/1);
+	  gcc_assert (TYPE_METHODS (current_class_type) == decl);
+	  TYPE_METHODS (current_class_type)
+	    = nreverse (TYPE_METHODS (current_class_type));
+	  DECL_CHAIN (decl) = save;
+	}
+
+      /* Reverse the method chain temporarily, so that we can find
+	 the clones after DECL.  The clones are supposed to be
+	 introduced one right after the other, so truncating the
+	 list at DECL for the temporary reversal will yield a very
+	 short list.  */
+      tree save = DECL_CHAIN (decl), abstract_decl = decl;
+      DECL_CHAIN (decl) = NULL_TREE;
+      TYPE_METHODS (current_class_type)
+	= nreverse (TYPE_METHODS (current_class_type));
+      for (decl = DECL_CHAIN (decl); decl; decl = DECL_CHAIN (decl))
+	if (DECL_NAME (decl) == identifier)
+	  break;
+      TYPE_METHODS (current_class_type)
+	= nreverse (TYPE_METHODS (current_class_type));
+      DECL_CHAIN (abstract_decl) = save;
+    }
+
   rest_of_decl_compilation (decl, toplevel_bindings_p (), 0);
 
   return convert_out (ctx->preserve (decl));
@@ -1245,9 +1275,6 @@ plugin_finish_record_or_union (cc1_plugin::connection *,
   gcc_assert (compare_tree_int (TYPE_SIZE_UNIT (record_or_union_type),
 				size_in_bytes) == 0);
 
-  // FIXME: end_template_decl if it's a template?  I don't think so,
-  // we're only defining specializations.  -lxo
-
   return 1;
 }
 
@@ -1957,8 +1984,6 @@ plugin_start_specialize_class_template (cc1_plugin::connection *self,
   source_location loc = ctx->get_source_location (filename, line_number);
   tree name = convert_in (template_decl);
 
-  // begin_specialization (); // hopefully we don't really need this
-
   tree tdecl = finish_template_type (name, targlist (args), false);;
   DECL_SOURCE_LOCATION (tdecl) = loc;
