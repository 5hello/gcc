Bottom: af689840b739ccdcc57bdb5fdef8b8ab2a3ce278
Top:    949f63d5e29602dfe75426d6142a2297a8ace450
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-04-08 03:50:13 -0300

Refresh of access-control.patch

---

diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 7bc77f8..2574b46 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -440,6 +440,29 @@ plugin_get_current_binding_level (cc1_plugin::connection *)
 }
 
 
+static inline void
+set_access_flags (tree decl, enum gcc_cp_symbol_kind flags)
+{
+  gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !DECL_CLASS_SCOPE_P (decl));
+
+  switch (flags & GCC_CP_ACCESS_MASK)
+    {
+    case GCC_CP_ACCESS_PRIVATE:
+      TREE_PRIVATE (decl) = true;
+      break;
+
+    case GCC_CP_ACCESS_PROTECTED:
+      TREE_PROTECTED (decl) = true;
+      break;
+
+    case GCC_CP_ACCESS_PUBLIC:
+      break;
+
+    default:
+      break;
+    }
+}
+
 gcc_decl
 plugin_new_decl (cc1_plugin::connection *self,
 		 const char *name,
@@ -499,7 +522,6 @@ plugin_new_decl (cc1_plugin::connection *self,
   tree_code opcode = ERROR_MARK;
 
   gcc_assert (!(sym_kind & GCC_CP_ACCESS_MASK) == !class_member_p);
-  /* FIXME: use access bits.  */
 
   if (code == FUNCTION_DECL)
     {
@@ -786,6 +808,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 	      fns = CLASSTYPE_DESTRUCTORS (current_class_type);
 	    }
 	  DECL_CONTEXT (decl) = FROB_CONTEXT (current_class_type);
+	  set_access_flags (decl, flags);
 	  maybe_retrofit_in_chrg (decl);
 	  for (; fns; fns = OVL_NEXT (fns))
 	    {
@@ -880,6 +903,8 @@ plugin_new_decl (cc1_plugin::connection *self,
   else if (at_namespace_scope_p ())
     DECL_CONTEXT (decl) = FROB_CONTEXT (current_decl_namespace ());
 
+  set_access_flags (decl, flags);
+
   if (sym_kind != GCC_CP_SYMBOL_TYPEDEF)
     {
       decl_addr_value value;
@@ -972,14 +997,31 @@ start_class_def (tree type,
     {
       for (int i = 0; i < base_classes->n_elements; i++)
 	{
+	  tree access;
+
 	  gcc_assert ((base_classes->flags[i] & GCC_CP_SYMBOL_MASK)
 		      == GCC_CP_SYMBOL_BASECLASS);
-	  gcc_assert ((base_classes->flags[i] & GCC_CP_ACCESS_MASK) != 0);
-	  /* FIXME: use access bits.  */
+
+	  switch (base_classes->flags[i] & GCC_CP_ACCESS_MASK)
+	    {
+	    case GCC_CP_ACCESS_PRIVATE:
+	      access = ridpointers[(int)RID_PRIVATE];
+	      break;
+
+	    case GCC_CP_ACCESS_PROTECTED:
+	      access = ridpointers[(int)RID_PROTECTED];
+	      break;
+
+	    case GCC_CP_ACCESS_PUBLIC:
+	      access = ridpointers[(int)RID_PUBLIC];
+	      break;
+
+	    default:
+	      gcc_unreachable ();
+	    }
 
 	  tree base = finish_base_specifier
-	    (convert_in (base_classes->elements[i]),
-	     access_default_node,
+	    (convert_in (base_classes->elements[i]), access,
 	     (base_classes->flags[i] & GCC_CP_FLAG_BASECLASS_VIRTUAL) != 0);
 	  TREE_CHAIN (base) = bases;
 	  bases = base;
@@ -1021,12 +1063,16 @@ plugin_start_new_class_type (cc1_plugin::connection *self,
   gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
 			  | GCC_CP_FLAG_MASK_CLASS))) == 0);
   gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
-  /* FIXME: use access bits.  */
-  /* FIXME: use class flags.  */
 
   tree type = build_named_class_type (RECORD_TYPE, name, base_classes,
 				      ctx->get_source_location (filename,
 								line_number));
+  tree decl = TYPE_NAME (type);
+
+  set_access_flags (decl, flags);
+
+  if (!(flags & GCC_CP_FLAG_CLASS_IS_STRUCT))
+    CLASSTYPE_DECLARED_CLASS (type) = true;
 
   return convert_out (ctx->preserve (type));
 }
@@ -1043,11 +1089,13 @@ plugin_start_new_union_type (cc1_plugin::connection *self,
   gcc_assert ((flags & GCC_CP_SYMBOL_MASK) == GCC_CP_SYMBOL_UNION);
   gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK))) == 0);
   gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
-  /* FIXME: use access bits.  */
 
   tree type = build_named_class_type (UNION_TYPE, name, NULL,
 				      ctx->get_source_location (filename,
 								line_number));
+  tree decl = TYPE_NAME (type);
+
+  set_access_flags (decl, flags);
 
   return convert_out (ctx->preserve (type));
 }
@@ -1069,7 +1117,6 @@ plugin_new_field (cc1_plugin::connection *,
   gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
 			  | GCC_CP_FLAG_MASK_FIELD))) == 0);
   gcc_assert ((flags & GCC_CP_ACCESS_MASK));
-  /* FIXME: use access bits.  */
 
   /* Note that gdb does not preserve the location of field decls, so
      we can't provide a decent location here.  */
@@ -1077,6 +1124,8 @@ plugin_new_field (cc1_plugin::connection *,
 			  get_identifier (field_name), field_type);
   DECL_FIELD_CONTEXT (decl) = record_or_union_type;
 
+  set_access_flags (decl, flags);
+
   if ((flags & GCC_CP_FLAG_FIELD_MUTABLE) != 0)
     DECL_MUTABLE_P (decl) = 1;
 
@@ -1141,7 +1190,6 @@ plugin_start_new_enum_type (cc1_plugin::connection *self,
   gcc_assert ((flags & (~(GCC_CP_SYMBOL_MASK | GCC_CP_ACCESS_MASK
 			  | GCC_CP_FLAG_MASK_ENUM))) == 0);
   gcc_assert (!(flags & GCC_CP_ACCESS_MASK) == !at_class_scope_p ());
-  /* FIXME: use access bits.  */
 
   if (underlying_int_type == error_mark_node)
     return convert_out (error_mark_node);
@@ -1164,6 +1212,8 @@ plugin_start_new_enum_type (cc1_plugin::connection *self,
 
   safe_pushtag (DECL_NAME (type_decl), type, ts_current);
 
+  set_access_flags (type_decl, flags);
+
   return convert_out (ctx->preserve (type));
 }
