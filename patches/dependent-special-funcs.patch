Bottom: da89f4ba0ba98702f0af9315171a76b333bd3c15
Top:    f01c07b33d36f554c3795dd734f232576262bbd6
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-11 05:30:57 -0300

support dependent overloaded operators and other special member functions

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 2d8bb7a..d149847 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -429,21 +429,45 @@ GCC_METHOD2 (gcc_type, new_dependent_typespec,
 	     gcc_utempl,		   /* Argument TEMPLATE_DECL.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
-/* Build a template-dependent value expression (e.g., T::val or
-   T::template f<X>).  ENCLOSING_TYPE should be the template-dependent
-   nested name specifier (e.g., T), ID should be the name of the
-   member of the ENCLOSING_TYPE (e.g., val or f), and TARGS should
-   list template arguments (e.g. <X>) when f is to name a template
-   function, or be NULL otherwise.  */
-
-GCC_METHOD3 (gcc_decl, new_dependent_value_expr,
-	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
-	     const char *,			      /* Argument ID.  */
+/* Build a template-dependent value expression (e.g., S::val or
+   S::template mtf<X>, or unqualified f or template tf<X>).
+
+   ENCLOSING_SCOPE should be a template-dependent nested name
+   specifier (e.g., T), a resolved namespace or class decl, or NULL
+   for unqualified names; ID should be the name of the member of the
+   ENCLOSING_SCOPE (e.g., val or mtf) or unqualified overloaded
+   function; and TARGS should list template arguments (e.g. <X>) when
+   mtf or tf are to name a template function, or be NULL otherwise.
+
+   Unqualified names and namespace- or class-qualified names can only
+   resolve to overloaded functions, to be used in contexts that
+   involve overload resolution that cannot be resolved because of
+   template-dependent argument or return types, such as call
+   expressions with template-dependent arguments, conversion
+   expressions to function types with template-dependent argument
+   types or the like.  Other cases of unqualified or
+   non-template-dependent-qualified names should NOT use this
+   function, and use decl_expr to convert the appropriate function or
+   object declaration to an expression.
+
+   If ID is the name of a special member function, FLAGS should be
+   GCC_CP_SYMBOL_FUNCTION|GCC_CP_FLAG_SPECIAL_FUNCTION, and ID should
+   be one of the encodings for special member functions documented in
+   new_decl.  Otherwise, FLAGS should be GCC_CP_SYMBOL_MASK, which
+   suggests the symbol kind is not known (though we know it is not a
+   type).
+
+   If ID denotes a conversion operator, CONV_TYPE should name the
+   target type of the conversion.  Otherwise, CONV_TYPE must be
+   NULL.  */
+
+GCC_METHOD5 (gcc_expr, new_dependent_value_expr,
+	     gcc_decl,			 /* Argument ENCLOSING_SCOPE.  */
+	     enum gcc_cp_symbol_kind,		   /* Argument FLAGS.  */
+	     const char *,			    /* Argument NAME.  */
+	     gcc_type,			       /* Argument CONV_TYPE.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
-// FIXME: the above needs to support special member function names and
-// overloaded operator names too.
-
 /* Build a gcc_expr for the value VALUE in type TYPE.  */
 
 GCC_METHOD2 (gcc_expr, literal_expr,
@@ -501,6 +525,7 @@ GCC_METHOD3 (gcc_expr, type_value_expr,
 
 /* Return the type of the gcc_expr OPERAND.
    Use this for decltype.
+   For decltype (auto), pass a NULL OPERAND.
 
    Note: for template-dependent expressions, the result is NULL,
    because the type is only computed when template argument
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 1d0d4c7..3710a3a8 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-11
+  GCC_CP_FE_VERSION_0 = 0xffffffff-12
 };
 
 /* Qualifiers.  */
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index d258f35..e359bc5 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1823,18 +1823,262 @@ plugin_new_dependent_typespec (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (TREE_TYPE (decl)));
 }
 
-gcc_decl
+gcc_expr
 plugin_new_dependent_value_expr (cc1_plugin::connection *self,
-				 gcc_type enclosing_type,
-				 const char *id,
+				 gcc_decl enclosing_scope,
+				 enum gcc_cp_symbol_kind flags,
+				 const char *name,
+				 gcc_type conv_type_in,
 				 const gcc_cp_template_args *targs)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
-  tree type = convert_in (enclosing_type);
-  tree name = get_identifier (id);
+  tree scope = convert_in (enclosing_scope);
+  tree conv_type = convert_in (conv_type_in);
+  tree identifier;
+
+  if (TREE_CODE (scope) != NAMESPACE_DECL)
+    {
+      tree type = TREE_TYPE (scope);
+      gcc_assert (TYPE_NAME (type) == scope);
+      scope = type;
+    }
+
+  if (flags == (GCC_CP_SYMBOL_FUNCTION | GCC_CP_FLAG_SPECIAL_FUNCTION))
+    {
+      bool assop = false, convop = false;
+      tree_code opcode = ERROR_MARK;
+
+      switch (CHARS2 (name[0], name[1]))
+	{
+	case CHARS2 ('C', 0x0): // ctor base declaration
+	case CHARS2 ('C', ' '):
+	case CHARS2 ('C', '1'):
+	case CHARS2 ('C', '2'):
+	case CHARS2 ('C', '4'):
+	  identifier = ctor_identifier;
+	  break;
+	case CHARS2 ('D', 0x0): // dtor base declaration
+	case CHARS2 ('D', ' '):
+	case CHARS2 ('D', '0'):
+	case CHARS2 ('D', '1'):
+	case CHARS2 ('D', '2'):
+	case CHARS2 ('D', '4'):
+	  gcc_assert (!targs);
+	  identifier = dtor_identifier;
+	  break;
+	case CHARS2 ('n', 'w'): // operator new
+	  opcode = NEW_EXPR;
+	  break;
+	case CHARS2 ('n', 'a'): // operator new[]
+	  opcode = VEC_NEW_EXPR;
+	  break;
+	case CHARS2 ('d', 'l'): // operator delete
+	  opcode = DELETE_EXPR;
+	  break;
+	case CHARS2 ('d', 'a'): // operator delete[]
+	  opcode = VEC_DELETE_EXPR;
+	  break;
+	case CHARS2 ('p', 's'): // operator + (unary)
+	  opcode = PLUS_EXPR;
+	  break;
+	case CHARS2 ('n', 'g'): // operator - (unary)
+	  opcode = MINUS_EXPR;
+	  break;
+	case CHARS2 ('a', 'd'): // operator & (unary)
+	  opcode = BIT_AND_EXPR;
+	  break;
+	case CHARS2 ('d', 'e'): // operator * (unary)
+	  opcode = MULT_EXPR;
+	  break;
+	case CHARS2 ('c', 'o'): // operator ~
+	  opcode = BIT_NOT_EXPR;
+	  break;
+	case CHARS2 ('p', 'l'): // operator +
+	  opcode = PLUS_EXPR;
+	  break;
+	case CHARS2 ('m', 'i'): // operator -
+	  opcode = MINUS_EXPR;
+	  break;
+	case CHARS2 ('m', 'l'): // operator *
+	  opcode = MULT_EXPR;
+	  break;
+	case CHARS2 ('d', 'v'): // operator /
+	  opcode = TRUNC_DIV_EXPR;
+	  break;
+	case CHARS2 ('r', 'm'): // operator %
+	  opcode = TRUNC_MOD_EXPR;
+	  break;
+	case CHARS2 ('a', 'n'): // operator &
+	  opcode = BIT_AND_EXPR;
+	  break;
+	case CHARS2 ('o', 'r'): // operator |
+	  opcode = BIT_IOR_EXPR;
+	  break;
+	case CHARS2 ('e', 'o'): // operator ^
+	  opcode = BIT_XOR_EXPR;
+	  break;
+	case CHARS2 ('a', 'S'): // operator =
+	  opcode = NOP_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('p', 'L'): // operator +=
+	  opcode = PLUS_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('m', 'I'): // operator -=
+	  opcode = MINUS_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('m', 'L'): // operator *=
+	  opcode = MULT_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('d', 'V'): // operator /=
+	  opcode = TRUNC_DIV_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('r', 'M'): // operator %=
+	  opcode = TRUNC_MOD_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('a', 'N'): // operator &=
+	  opcode = BIT_AND_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('o', 'R'): // operator |=
+	  opcode = BIT_IOR_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('e', 'O'): // operator ^=
+	  opcode = BIT_XOR_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('l', 's'): // operator <<
+	  opcode = LSHIFT_EXPR;
+	  break;
+	case CHARS2 ('r', 's'): // operator >>
+	  opcode = RSHIFT_EXPR;
+	  break;
+	case CHARS2 ('l', 'S'): // operator <<=
+	  opcode = LSHIFT_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('r', 'S'): // operator >>=
+	  opcode = RSHIFT_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('e', 'q'): // operator ==
+	  opcode = EQ_EXPR;
+	  break;
+	case CHARS2 ('n', 'e'): // operator !=
+	  opcode = NE_EXPR;
+	  break;
+	case CHARS2 ('l', 't'): // operator <
+	  opcode = LT_EXPR;
+	  break;
+	case CHARS2 ('g', 't'): // operator >
+	  opcode = GT_EXPR;
+	  break;
+	case CHARS2 ('l', 'e'): // operator <=
+	  opcode = LE_EXPR;
+	  break;
+	case CHARS2 ('g', 'e'): // operator >=
+	  opcode = GE_EXPR;
+	  break;
+	case CHARS2 ('n', 't'): // operator !
+	  opcode = TRUTH_NOT_EXPR;
+	  break;
+	case CHARS2 ('a', 'a'): // operator &&
+	  opcode = TRUTH_ANDIF_EXPR;
+	  break;
+	case CHARS2 ('o', 'o'): // operator ||
+	  opcode = TRUTH_ORIF_EXPR;
+	  break;
+	case CHARS2 ('p', 'p'): // operator ++
+	  opcode = POSTINCREMENT_EXPR;
+	  break;
+	case CHARS2 ('m', 'm'): // operator --
+	  opcode = POSTDECREMENT_EXPR;
+	  break;
+	case CHARS2 ('c', 'm'): // operator ,
+	  opcode = COMPOUND_EXPR;
+	  break;
+	case CHARS2 ('p', 'm'): // operator ->*
+	  opcode = MEMBER_REF;
+	  break;
+	case CHARS2 ('p', 't'): // operator ->
+	  opcode = COMPONENT_REF;
+	  break;
+	case CHARS2 ('c', 'l'): // operator ()
+	  opcode = CALL_EXPR;
+	  break;
+	case CHARS2 ('i', 'x'): // operator []
+	  opcode = ARRAY_REF;
+	  break;
+	case CHARS2 ('c', 'v'): // operator <T> (conversion operator)
+	  convop = true;
+	  identifier = mangle_conv_op_name_for_type (conv_type);
+	  break;
+	  // C++11-only:
+	case CHARS2 ('l', 'i'): // operator "" <id>
+	  {
+	    char *id = (char *)name + 2;
+	    bool freeid = false;
+	    if (*id >= '0' && *id <= '9')
+	      {
+		unsigned len = 0;
+		do
+		  {
+		    len *= 10;
+		    len += id[0] - '0';
+		    id++;
+		  }
+		while (*id && *id >= '0' && *id <= '9');
+		id = xstrndup (id, len);
+		freeid = true;
+	      }
+	    identifier = ansi_litopname (id);
+	    if (freeid)
+	      free (id);
+	  }
+	  break;
+	case CHARS2 ('q', 'u'): // ternary operator, not overloadable.
+	default:
+	  gcc_unreachable ();
+	}
+
+      gcc_assert (convop || !conv_type);
+
+      if (opcode != ERROR_MARK)
+	{
+	  if (assop)
+	    identifier = ansi_assopname (opcode);
+	  else
+	    identifier = ansi_opname (opcode);
+	}
+
+      gcc_assert (identifier);
+    }
+  else
+    {
+      gcc_assert (flags == GCC_CP_SYMBOL_MASK);
+      gcc_assert (!conv_type);
+      identifier = get_identifier (name);
+    }
+  tree res = identifier;
+  if (!scope)
+    res = lookup_name_real (res, 0, 0, true, 0, 0);
+  else if (!TYPE_P (scope) || !dependent_scope_p (scope))
+    {
+      res = lookup_qualified_name (scope, res, false, true);
+      /* We've already resolved the name in the scope, so skip the
+	 build_qualified_name call below.  */
+      scope = NULL;
+    }
   if (targs)
-    name = lookup_template_function (name, targlist (targs));
-  tree res = build_qualified_name (NULL_TREE, type, name, !!targs);
+    res = lookup_template_function (res, targlist (targs));
+  if (scope)
+    res = build_qualified_name (NULL_TREE, scope, res, !!targs);
   return convert_out (ctx->preserve (res));
 }
 
@@ -2057,7 +2301,14 @@ plugin_expr_type (cc1_plugin::connection *,
 		  gcc_expr operand)
 {
   tree op0 = convert_in (operand);
-  tree type = TREE_TYPE (op0);
+  tree type;
+  if (op0)
+    type = TREE_TYPE (op0);
+  else
+    {
+      type = make_decltype_auto ();
+      AUTO_IS_DECLTYPE (type) = true;
+    }
   return convert_out (type);
 }
