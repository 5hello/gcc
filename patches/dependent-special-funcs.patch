Bottom: da89f4ba0ba98702f0af9315171a76b333bd3c15
Top:    0f4d72149256235783b6803753586825e5122870
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-05-11 05:30:57 -0300

support dependent overloaded operators and other special member functions

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 2d8bb7a..855f4eb 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -430,20 +430,34 @@ GCC_METHOD2 (gcc_type, new_dependent_typespec,
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
 /* Build a template-dependent value expression (e.g., T::val or
-   T::template f<X>).  ENCLOSING_TYPE should be the template-dependent
-   nested name specifier (e.g., T), ID should be the name of the
-   member of the ENCLOSING_TYPE (e.g., val or f), and TARGS should
-   list template arguments (e.g. <X>) when f is to name a template
-   function, or be NULL otherwise.  */
-
-GCC_METHOD3 (gcc_decl, new_dependent_value_expr,
+   T::template mtf<X>, or unqualified f or template tf<X>).
+   ENCLOSING_TYPE should be the template-dependent nested name
+   specifier (e.g., T) or NULL for unqualified names, ID should be the
+   name of the member of the ENCLOSING_TYPE (e.g., val or mtf) or
+   unqualified overloaded function, and TARGS should list template
+   arguments (e.g. <X>) when mtf or tf are to name a template
+   function, or be NULL otherwise.  Unqualified template-dependent
+   names can only name overloaded functions, to be used in call
+   expressions with template-dependent arguments.
+
+   If ID is the name of a special member function, FLAGS should be
+   GCC_CP_SYMBOL_FUNCTION|GCC_CP_FLAG_SPECIAL_FUNCTION, and ID should
+   be one of the encodings for special member functions documented in
+   new_decl.  Otherwise, FLAGS should be GCC_CP_SYMBOL_MASK, which
+   suggests the symbol kind is not known (though we know it is not a
+   type).
+
+   If ID denotes a conversion operator, CONV_TYPE should name the
+   target type of the conversion.  Otherwise, CONV_TYPE must be
+   NULL.  */
+
+GCC_METHOD5 (gcc_decl, new_dependent_value_expr,
 	     gcc_type,			  /* Argument ENCLOSING_TYPE.  */
-	     const char *,			      /* Argument ID.  */
+	     enum gcc_cp_symbol_kind,		   /* Argument FLAGS.  */
+	     const char *,			    /* Argument NAME.  */
+	     gcc_type,			       /* Argument CONV_TYPE.  */
 	     const struct gcc_cp_template_args *)  /* Argument TARGS.  */
 
-// FIXME: the above needs to support special member function names and
-// overloaded operator names too.
-
 /* Build a gcc_expr for the value VALUE in type TYPE.  */
 
 GCC_METHOD2 (gcc_expr, literal_expr,
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index 1d0d4c7..3710a3a8 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-11
+  GCC_CP_FE_VERSION_0 = 0xffffffff-12
 };
 
 /* Qualifiers.  */
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index d258f35..d51c04c 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -1826,15 +1826,243 @@ plugin_new_dependent_typespec (cc1_plugin::connection *self,
 gcc_decl
 plugin_new_dependent_value_expr (cc1_plugin::connection *self,
 				 gcc_type enclosing_type,
-				 const char *id,
+				 enum gcc_cp_symbol_kind flags,
+				 const char *name,
+				 gcc_type conv_type_in,
 				 const gcc_cp_template_args *targs)
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   tree type = convert_in (enclosing_type);
-  tree name = get_identifier (id);
+  tree conv_type = convert_in (conv_type_in);
+  tree identifier;
+
+  if (flags == (GCC_CP_SYMBOL_FUNCTION | GCC_CP_FLAG_SPECIAL_FUNCTION))
+    {
+      bool assop = false, convop = false;
+      tree_code opcode = ERROR_MARK;
+
+      switch (CHARS2 (name[0], name[1]))
+	{
+	case CHARS2 ('C', 0x0): // ctor base declaration
+	case CHARS2 ('C', ' '):
+	case CHARS2 ('C', '1'):
+	case CHARS2 ('C', '2'):
+	case CHARS2 ('C', '4'):
+	  identifier = ctor_identifier;
+	  break;
+	case CHARS2 ('D', 0x0): // dtor base declaration
+	case CHARS2 ('D', ' '):
+	case CHARS2 ('D', '0'):
+	case CHARS2 ('D', '1'):
+	case CHARS2 ('D', '2'):
+	case CHARS2 ('D', '4'):
+	  gcc_assert (!targs);
+	  identifier = dtor_identifier;
+	  break;
+	case CHARS2 ('n', 'w'): // operator new
+	  opcode = NEW_EXPR;
+	  break;
+	case CHARS2 ('n', 'a'): // operator new[]
+	  opcode = VEC_NEW_EXPR;
+	  break;
+	case CHARS2 ('d', 'l'): // operator delete
+	  opcode = DELETE_EXPR;
+	  break;
+	case CHARS2 ('d', 'a'): // operator delete[]
+	  opcode = VEC_DELETE_EXPR;
+	  break;
+	case CHARS2 ('p', 's'): // operator + (unary)
+	  opcode = PLUS_EXPR;
+	  break;
+	case CHARS2 ('n', 'g'): // operator - (unary)
+	  opcode = MINUS_EXPR;
+	  break;
+	case CHARS2 ('a', 'd'): // operator & (unary)
+	  opcode = BIT_AND_EXPR;
+	  break;
+	case CHARS2 ('d', 'e'): // operator * (unary)
+	  opcode = MULT_EXPR;
+	  break;
+	case CHARS2 ('c', 'o'): // operator ~
+	  opcode = BIT_NOT_EXPR;
+	  break;
+	case CHARS2 ('p', 'l'): // operator +
+	  opcode = PLUS_EXPR;
+	  break;
+	case CHARS2 ('m', 'i'): // operator -
+	  opcode = MINUS_EXPR;
+	  break;
+	case CHARS2 ('m', 'l'): // operator *
+	  opcode = MULT_EXPR;
+	  break;
+	case CHARS2 ('d', 'v'): // operator /
+	  opcode = TRUNC_DIV_EXPR;
+	  break;
+	case CHARS2 ('r', 'm'): // operator %
+	  opcode = TRUNC_MOD_EXPR;
+	  break;
+	case CHARS2 ('a', 'n'): // operator &
+	  opcode = BIT_AND_EXPR;
+	  break;
+	case CHARS2 ('o', 'r'): // operator |
+	  opcode = BIT_IOR_EXPR;
+	  break;
+	case CHARS2 ('e', 'o'): // operator ^
+	  opcode = BIT_XOR_EXPR;
+	  break;
+	case CHARS2 ('a', 'S'): // operator =
+	  opcode = NOP_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('p', 'L'): // operator +=
+	  opcode = PLUS_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('m', 'I'): // operator -=
+	  opcode = MINUS_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('m', 'L'): // operator *=
+	  opcode = MULT_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('d', 'V'): // operator /=
+	  opcode = TRUNC_DIV_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('r', 'M'): // operator %=
+	  opcode = TRUNC_MOD_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('a', 'N'): // operator &=
+	  opcode = BIT_AND_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('o', 'R'): // operator |=
+	  opcode = BIT_IOR_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('e', 'O'): // operator ^=
+	  opcode = BIT_XOR_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('l', 's'): // operator <<
+	  opcode = LSHIFT_EXPR;
+	  break;
+	case CHARS2 ('r', 's'): // operator >>
+	  opcode = RSHIFT_EXPR;
+	  break;
+	case CHARS2 ('l', 'S'): // operator <<=
+	  opcode = LSHIFT_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('r', 'S'): // operator >>=
+	  opcode = RSHIFT_EXPR;
+	  assop = true;
+	  break;
+	case CHARS2 ('e', 'q'): // operator ==
+	  opcode = EQ_EXPR;
+	  break;
+	case CHARS2 ('n', 'e'): // operator !=
+	  opcode = NE_EXPR;
+	  break;
+	case CHARS2 ('l', 't'): // operator <
+	  opcode = LT_EXPR;
+	  break;
+	case CHARS2 ('g', 't'): // operator >
+	  opcode = GT_EXPR;
+	  break;
+	case CHARS2 ('l', 'e'): // operator <=
+	  opcode = LE_EXPR;
+	  break;
+	case CHARS2 ('g', 'e'): // operator >=
+	  opcode = GE_EXPR;
+	  break;
+	case CHARS2 ('n', 't'): // operator !
+	  opcode = TRUTH_NOT_EXPR;
+	  break;
+	case CHARS2 ('a', 'a'): // operator &&
+	  opcode = TRUTH_ANDIF_EXPR;
+	  break;
+	case CHARS2 ('o', 'o'): // operator ||
+	  opcode = TRUTH_ORIF_EXPR;
+	  break;
+	case CHARS2 ('p', 'p'): // operator ++
+	  opcode = POSTINCREMENT_EXPR;
+	  break;
+	case CHARS2 ('m', 'm'): // operator --
+	  opcode = POSTDECREMENT_EXPR;
+	  break;
+	case CHARS2 ('c', 'm'): // operator ,
+	  opcode = COMPOUND_EXPR;
+	  break;
+	case CHARS2 ('p', 'm'): // operator ->*
+	  opcode = MEMBER_REF;
+	  break;
+	case CHARS2 ('p', 't'): // operator ->
+	  opcode = COMPONENT_REF;
+	  break;
+	case CHARS2 ('c', 'l'): // operator ()
+	  opcode = CALL_EXPR;
+	  break;
+	case CHARS2 ('i', 'x'): // operator []
+	  opcode = ARRAY_REF;
+	  break;
+	case CHARS2 ('c', 'v'): // operator <T> (conversion operator)
+	  convop = true;
+	  identifier = mangle_conv_op_name_for_type (conv_type);
+	  break;
+	  // C++11-only:
+	case CHARS2 ('l', 'i'): // operator "" <id>
+	  {
+	    char *id = (char *)name + 2;
+	    bool freeid = false;
+	    if (*id >= '0' && *id <= '9')
+	      {
+		unsigned len = 0;
+		do
+		  {
+		    len *= 10;
+		    len += id[0] - '0';
+		    id++;
+		  }
+		while (*id && *id >= '0' && *id <= '9');
+		id = xstrndup (id, len);
+		freeid = true;
+	      }
+	    identifier = ansi_litopname (id);
+	    if (freeid)
+	      free (id);
+	  }
+	  break;
+	case CHARS2 ('q', 'u'): // ternary operator, not overloadable.
+	default:
+	  gcc_unreachable ();
+	}
+
+      gcc_assert (convop || !conv_type);
+
+      if (opcode != ERROR_MARK)
+	{
+	  if (assop)
+	    identifier = ansi_assopname (opcode);
+	  else
+	    identifier = ansi_opname (opcode);
+	}
+
+      gcc_assert (identifier);
+    }
+  else
+    {
+      gcc_assert (flags == GCC_CP_SYMBOL_MASK);
+      gcc_assert (!conv_type);
+      identifier = get_identifier (name);
+    }
   if (targs)
-    name = lookup_template_function (name, targlist (targs));
-  tree res = build_qualified_name (NULL_TREE, type, name, !!targs);
+    identifier = lookup_template_function (identifier, targlist (targs));
+  tree res = identifier;
+  if (type)
+    res = build_qualified_name (NULL_TREE, type, identifier, !!targs);
   return convert_out (ctx->preserve (res));
 }
