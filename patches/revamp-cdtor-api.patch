Bottom: 2c79b93f0d34235a258c62bb42ee9a34006ddbd0
Top:    4d04f6d05a3492b996abd2f4910e0efbe324f5f6
Author: Alexandre Oliva <aoliva@redhat.com>
Date:   2016-04-09 06:58:06 -0300

revamp cdtor api

---

diff --git a/include/gcc-cp-fe.def b/include/gcc-cp-fe.def
index 61ae8a6..0b41788 100644
--- a/include/gcc-cp-fe.def
+++ b/include/gcc-cp-fe.def
@@ -75,49 +75,38 @@ GCC_METHOD0 (gcc_decl, get_current_binding_level)
    to create the method type out of the class type and the function
    type.
 
-   For constructors, destructors and operator functions, set
-   GCC_CP_FLAG_SPECIAL_FUNCTION in SYM_KIND, in addition to any other
-   applicable flags, and pass as NAME a string starting with the
-   two-character mangling for the constructor or destructor variant
-   (C1, C2, D0, D1, or D2, see below) or for the operator name: "ps"
-   for unary plus, "mL" for multiply and assign, *=; etc.  Use "cv"
-   for type converstion operators (the target type portion may be
-   omitted, as it is taken from the return type in SYM_TYPE).  For
-   operator"", use "li" followed by the identifier (the mangled name
-   mandates digits specifying the length of the identifier; if
+   For operator functions, set GCC_CP_FLAG_SPECIAL_FUNCTION in
+   SYM_KIND, in addition to any other applicable flags, and pass as
+   NAME a string starting with the two-character mangling for operator
+   name: "ps" for unary plus, "mL" for multiply and assign, *=; etc.
+   Use "cv" for type converstion operators (the target type portion
+   may be omitted, as it is taken from the return type in SYM_TYPE).
+   For operator"", use "li" followed by the identifier (the mangled
+   name mandates digits specifying the length of the identifier; if
    present, they determine the end of the identifier, otherwise, the
    identifier extents to the end of the string, so that "li3_Kme" and
    "li_Km" are equivalent).
 
-   Constructors and destructors need special care, since for each
-   constructor prototype defined in the sources, two symbols are
-   defined in the object code: C1 initializes an instance of the class
-   (rather than of derived classes), including virtual base classes,
-   whereas C2 initializes a sub-object (of the given class type) of an
-   instance of some derived class (or a full object that doesn't have
-   any virtual base classes); for the destructor of each class, there
-   may be up to three variants (not counting virtual thunks): D0 and
-   D1 destruct an instance of the class, including virtual base
-   classes, but only the former calls operator delete to release the
-   object's storage at the end; D2 destructs a sub-object (of the
-   given class type) of an instance of a derived class (or a full
-   object that doesn't have any virtual base classes).  new_decl
-   expects to be called once for each constructor and destructor
-   variant; the first time it sees a constructor or destructor with a
-   given prototype, it will create the member declaration and all
-   appropriate variants; then, and at subsequent calls for other
-   variants, it will select the artificial clone declaration for the
-   chosen variant, and set up the address or substitution name for
-   that variant only.
+   Constructors and destructors need special care, because for each
+   constructor and destructor there may be multiple clones defined
+   internally by the compiler.  With new_decl, you can introduce the
+   base declaration of a constructor or a destructor, setting
+   GCC_CP_FLAG_SPECIAL_FUNCTION the flag and using names starting with
+   capital "C" or "D", respectively, followed by a digit (see below),
+   a blank, or NUL ('\0').  DO NOT supply an ADDRESS or a
+   SUBSTITUTION_NAME to new_decl, it would be meaningless (and
+   rejected) for the base declaration; use define_cdtor_clone to
+   introduce the address of each clone.  For constructor templates,
+   declare the template with new_decl, and then, for each
+   specialization, introduce it with specialize_function_template, and
+   then define the addresses of each of its clones with
+   define_cdtor_clone.
 
    NAMEs for GCC_CP_FLAG_SPECIAL_FUNCTION:
 
      NAME    meaning
-     C1      in-charge constructor
-     C2      not-in-charge constructor
-     D0      deleting destructor
-     D1      in-charge destructor
-     D2      not-in-charge destructor
+     C?      constructor base declaration (? may be 1, 2, 4, blank or NUL)
+     D?      destructor base declaration (? may be 0, 1, 2, 4, blank or NUL)
      nw      operator new
      na      operator new[]
      dl      operator delete
@@ -183,6 +172,43 @@ GCC_METHOD7 (gcc_decl, new_decl,
 	     const char *,	      /* Argument FILENAME.  */
 	     unsigned int)	      /* Argument LINE_NUMBER.  */
 
+/* Supply the ADDRESS of one of the multiple clones of constructor or
+   destructor CDTOR.  The clone is selected using the following
+   name mangling conventions:
+
+     C1      in-charge constructor
+     C2      not-in-charge constructor
+     C4      unified constructor
+     D0      deleting destructor
+     D1      in-charge destructor
+     D2      not-in-charge destructor
+     D4      unified destructor
+
+   The following information is not necessary to use the API.
+
+   C1 initializes an instance of the class (rather than of derived
+   classes), including virtual base classes, whereas C2 initializes a
+   sub-object (of the given class type) of an instance of some derived
+   class (or a full object that doesn't have any virtual base
+   classes).
+
+   D0 and D1 destruct an instance of the class, including virtual base
+   classes, but only the former calls operator delete to release the
+   object's storage at the end; D2 destructs a sub-object (of the
+   given class type) of an instance of a derived class (or a full
+   object that doesn't have any virtual base classes).
+
+   The [CD]4 manglings (and symbol definitions) are non-standard, but
+   GCC uses them in some cases: rather than assuming they are
+   in-charge or not-in-charge, they test the implicit argument that
+   the others ignore to tell how to behave.  These are defined in very
+   rare cases of virtual inheritance and cdtor prototypes.  */
+
+GCC_METHOD3 (gcc_decl, define_cdtor_clone,
+	     const char *,	      /* Argument NAME.  */
+	     gcc_decl,		      /* Argument CDTOR.  */
+	     gcc_address)	      /* Argument ADDRESS.  */
+
 /* Declare DECL as a friend of the current class scope.  DECL may be a
    function or a class, be they template generics, template
    specializations or not templates.  */
diff --git a/include/gcc-cp-interface.h b/include/gcc-cp-interface.h
index e932a18..3ae4def 100644
--- a/include/gcc-cp-interface.h
+++ b/include/gcc-cp-interface.h
@@ -41,7 +41,7 @@ struct gcc_cp_context;
 
 enum gcc_cp_api_version
 {
-  GCC_CP_FE_VERSION_0 = 0xffffffff-8
+  GCC_CP_FE_VERSION_0 = 0xffffffff-9
 };
 
 /* Qualifiers.  */
diff --git a/libcc1/libcp1plugin.cc b/libcc1/libcp1plugin.cc
index 796e34a..beceeb5 100644
--- a/libcc1/libcp1plugin.cc
+++ b/libcc1/libcp1plugin.cc
@@ -494,7 +494,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 {
   plugin_context *ctx = static_cast<plugin_context *> (self);
   gcc_assert (!strchr (name, ':')); // FIXME: this can go eventually.
-  tree identifier = get_identifier (name);
+
   enum tree_code code;
   tree decl;
   tree sym_type = convert_in (sym_type_in);
@@ -559,6 +559,11 @@ plugin_new_decl (cc1_plugin::connection *self,
 
   gcc_assert (!(acc_flags & GCC_CP_ACCESS_MASK) == !class_member_p);
 
+  tree identifier;
+  if (code != FUNCTION_DECL
+      || !(sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION))
+    identifier = get_identifier (name);
+
   if (code == FUNCTION_DECL)
     {
       if (sym_flags & GCC_CP_FLAG_SPECIAL_FUNCTION)
@@ -566,45 +571,26 @@ plugin_new_decl (cc1_plugin::connection *self,
 #define CHARS2(f,s) (((unsigned char)f << CHAR_BIT) | (unsigned char)s)
 	  switch (CHARS2 (name[0], name[1]))
 	    {
-	    case CHARS2 ('C', '1'): // in-charge constructor
-	      identifier = complete_ctor_identifier;
-	      ctor = true;
-	      gcc_assert (!template_decl_p);
-	      break;
-	    case CHARS2 ('C', '2'): // not-in-charge constructor
-	      identifier = base_ctor_identifier;
-	      ctor = true;
-	      gcc_assert (!template_decl_p);
-	      break;
+	    case CHARS2 ('C', 0x0): // ctor base declaration
+	    case CHARS2 ('C', ' '):
+	    case CHARS2 ('C', '1'):
+	    case CHARS2 ('C', '2'):
 	    case CHARS2 ('C', '4'):
-	      identifier = ctor_identifier; // unified constructor
 	      ctor = true;
-	      /* This one can be a template, but we have no means for
-		 GDB to actively inform us the addresses of clones of
-		 a specialization.  That's kind of all right: we can
-		 get the addresses through the address oracle should
-		 we need them.  */
-	      break;
-	    case CHARS2 ('D', '0'): // deleting destructor
-	      identifier = deleting_dtor_identifier;
-	      dtor = true;
-	      gcc_assert (!template_decl_p);
-	      break;
-	    case CHARS2 ('D', '1'): // in-charge destructor
-	      identifier = complete_dtor_identifier;
-	      dtor = true;
-	      gcc_assert (!template_decl_p);
-	      break;
-	    case CHARS2 ('D', '2'): // not-in-charge destructor
-	      identifier = base_dtor_identifier;
-	      dtor = true;
-	      gcc_assert (!template_decl_p);
+	    cdtor:
+	      gcc_assert (!address);
+	      gcc_assert (!substitution_name);
+	      identifier = DECL_NAME (TYPE_NAME (current_class_type));
 	      break;
+	    case CHARS2 ('D', 0x0): // dtor base declaration
+	    case CHARS2 ('D', ' '):
+	    case CHARS2 ('D', '0'):
+	    case CHARS2 ('D', '1'):
+	    case CHARS2 ('D', '2'):
 	    case CHARS2 ('D', '4'):
-	      identifier = dtor_identifier; // unified destructor
-	      dtor = true;
 	      gcc_assert (!template_decl_p);
-	      break;
+	      dtor = true;
+	      goto cdtor;
 	    case CHARS2 ('n', 'w'): // operator new
 	      opcode = NEW_EXPR;
 	      break;
@@ -793,11 +779,12 @@ plugin_new_decl (cc1_plugin::connection *self,
 		identifier = ansi_opname (opcode);
 	    }
 	}
-      decl = build_lang_decl_loc (loc, code,
-				  (ctor || dtor)
-				  ? DECL_NAME (TYPE_NAME (current_class_type))
-				  : identifier, sym_type);
-      SET_DECL_LANGUAGE (decl, lang_cplusplus); // FIXME: current_lang_name is lang_name_c while compiling an extern "C" function, and we haven't switched to a global context at this point, and this breaks function overloading.
+      decl = build_lang_decl_loc (loc, code, identifier, sym_type);
+      /* FIXME: current_lang_name is lang_name_c while compiling an
+	 extern "C" function, and we haven't switched to a global
+	 context at this point, and this breaks function
+	 overloading.  */
+      SET_DECL_LANGUAGE (decl, lang_cplusplus);
       if (TREE_CODE (sym_type) == METHOD_TYPE)
 	DECL_ARGUMENTS (decl) = build_this_parm (current_class_type,
 						 cp_type_quals (sym_type));
@@ -921,7 +908,7 @@ plugin_new_decl (cc1_plugin::connection *self,
 
   if (sym_kind != GCC_CP_SYMBOL_TYPEDEF
       && sym_kind != GCC_CP_SYMBOL_CLASS
-      && !template_decl_p)
+      && !template_decl_p && !ctor && !dtor)
     {
       decl_addr_value value;
 
@@ -945,37 +932,16 @@ plugin_new_decl (cc1_plugin::connection *self,
 	record_decl_address (ctx, value);
     }
 
-  tree fns = NULL_TREE;
-
   if (class_member_p && code == FUNCTION_DECL)
     {
       if (ctor || dtor)
-	{
-	  maybe_retrofit_in_chrg (decl);
-	  if (ctor)
-	    fns = CLASSTYPE_CONSTRUCTORS (current_class_type);
-	  if (dtor)
-	    fns = CLASSTYPE_DESTRUCTORS (current_class_type);
-	  for (; fns; fns = OVL_NEXT (fns))
-	    {
-	      tree fn = OVL_CURRENT (fns);
-	      if (TREE_TYPE (decl) == TREE_TYPE (fn))
-		{
-		  decl = fn;
-		  break;
-		}
-	    }
-	}
+	maybe_retrofit_in_chrg (decl);
 
       grok_special_member_properties (decl);
     }
 
   if (template_decl_p)
     {
-      /* Since we only accept template declarations of the unified
-	 ctor, we don't have to special-case ctors here.  */
-      gcc_assert (!ctor || !fns);
-
       decl = safe_push_template_decl (decl);
       
       end_template_decl ();
@@ -986,52 +952,28 @@ plugin_new_decl (cc1_plugin::connection *self,
       gcc_assert (!template_parm_scope_p ());
     }
   else if (code == RECORD_TYPE)
-    {
-      safe_pushtag (identifier, TREE_TYPE (decl), ts_current);
-    }
+    safe_pushtag (identifier, TREE_TYPE (decl), ts_current);
   else if (class_member_p)
-    {
-      if (!(ctor || dtor) || !fns)
-	finish_member_declaration (decl);
-    }
+    finish_member_declaration (decl);
   else
     decl = safe_pushdecl_maybe_friend (decl, false);
 
   if (ctor || dtor)
     {
-      if (!fns)
-	{
-	  /* ctors and dtors clones are chained after DECL.
-	     However, we create the clones before TYPE_METHODS is
-	     reversed.  We test for cloned methods after reversal,
-	     however, and the test requires the clones to follow
-	     DECL.  So, we reverse the chain of clones now, so
-	     that it will come out in the right order after
-	     reversal.  */
-	  tree save = DECL_CHAIN (decl);
-	  DECL_CHAIN (decl) = NULL_TREE;
-	  clone_function_decl (decl, /*update_method_vec_p=*/1);
-	  gcc_assert (TYPE_METHODS (current_class_type) == decl);
-	  TYPE_METHODS (current_class_type)
-	    = nreverse (TYPE_METHODS (current_class_type));
-	  DECL_CHAIN (decl) = save;
-	}
-
-      /* Reverse the method chain temporarily, so that we can find
-	 the clones after DECL.  The clones are supposed to be
-	 introduced one right after the other, so truncating the
-	 list at DECL for the temporary reversal will yield a very
-	 short list.  */
-      tree save = DECL_CHAIN (decl), abstract_decl = decl;
+      /* ctors and dtors clones are chained after DECL.
+	 However, we create the clones before TYPE_METHODS is
+	 reversed.  We test for cloned methods after reversal,
+	 however, and the test requires the clones to follow
+	 DECL.  So, we reverse the chain of clones now, so
+	 that it will come out in the right order after
+	 reversal.  */
+      tree save = DECL_CHAIN (decl);
       DECL_CHAIN (decl) = NULL_TREE;
+      clone_function_decl (decl, /*update_method_vec_p=*/1);
+      gcc_assert (TYPE_METHODS (current_class_type) == decl);
       TYPE_METHODS (current_class_type)
 	= nreverse (TYPE_METHODS (current_class_type));
-      for (decl = DECL_CHAIN (decl); decl; decl = DECL_CHAIN (decl))
-	if (DECL_NAME (decl) == identifier)
-	  break;
-      TYPE_METHODS (current_class_type)
-	= nreverse (TYPE_METHODS (current_class_type));
-      DECL_CHAIN (abstract_decl) = save;
+      DECL_CHAIN (decl) = save;
     }
 
   rest_of_decl_compilation (decl, toplevel_bindings_p (), 0);
@@ -1039,6 +981,73 @@ plugin_new_decl (cc1_plugin::connection *self,
   return convert_out (ctx->preserve (decl));
 }
 
+gcc_decl
+plugin_define_cdtor_clone (cc1_plugin::connection *self,
+			   const char *name,
+			   gcc_decl cdtor_in,
+			   gcc_address address)
+{
+  plugin_context *ctx = static_cast<plugin_context *> (self);
+  tree decl = convert_in (cdtor_in);
+  bool ctor = false;
+  bool dtor = false;
+  tree identifier;
+
+  switch (CHARS2 (name[0], name[1]))
+    {
+    case CHARS2 ('C', '1'): // in-charge constructor
+      identifier = complete_ctor_identifier;
+      ctor = true;
+      break;
+    case CHARS2 ('C', '2'): // not-in-charge constructor
+      identifier = base_ctor_identifier;
+      ctor = true;
+      break;
+    case CHARS2 ('C', '4'):
+      identifier = ctor_identifier; // unified constructor
+      ctor = true;
+      break;
+    case CHARS2 ('D', '0'): // deleting destructor
+      identifier = deleting_dtor_identifier;
+      dtor = true;
+      break;
+    case CHARS2 ('D', '1'): // in-charge destructor
+      identifier = complete_dtor_identifier;
+      dtor = true;
+      break;
+    case CHARS2 ('D', '2'): // not-in-charge destructor
+      identifier = base_dtor_identifier;
+      dtor = true;
+      break;
+    case CHARS2 ('D', '4'):
+      identifier = dtor_identifier; // unified destructor
+      dtor = true;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  gcc_assert (!ctor != !dtor);
+  gcc_assert (ctor
+	      ? (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)
+		 && DECL_NAME (decl) == ctor_identifier)
+	      : (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl)
+		 && DECL_NAME (decl) == dtor_identifier));
+
+  while (decl && DECL_NAME (decl) != identifier)
+    {
+      decl = DECL_CHAIN (decl);
+      if (decl && !DECL_CLONED_FUNCTION_P (decl))
+	decl = NULL_TREE;
+    }
+  gcc_assert (decl);
+
+  record_decl_address (ctx, build_decl_addr_value (decl, address));
+
+  return convert_out (decl);
+}
+
 int
 plugin_new_friend (cc1_plugin::connection * /* self */,
 		   gcc_decl decl_in)
